diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 0c64748ccd..2ab97f614e 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1708,8 +1708,10 @@ class FilePathField(Field):
         return str(value)
 
     def formfield(self, **kwargs):
+        # If path is callable, call it to get the actual path
+        path = self.path() if callable(self.path) else self.path
         return super().formfield(**{
-            'path': self.path,
+            'path': path,
             'match': self.match,
             'recursive': self.recursive,
             'form_class': forms.FilePathField,
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..778a130652
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python
+"""
+Script to reproduce the FilePathField issue where path parameter doesn't accept callables.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR='/tmp/test_files'
+    )
+
+django.setup()
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create some test files
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+# Test the current behavior - this should work
+print("\n=== Testing current behavior (static path) ===")
+class LocalFilesStatic(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=os.path.join(test_dir, 'example_dir'))
+    
+    class Meta:
+        app_label = 'test'
+
+# Test the desired behavior - this should fail currently
+print("\n=== Testing desired behavior (callable path) ===")
+def get_file_path():
+    return os.path.join(test_dir, 'example_dir')
+
+try:
+    class LocalFilesCallable(models.Model):
+        name = models.CharField(max_length=255)
+        file = models.FilePathField(path=get_file_path)
+        
+        class Meta:
+            app_label = 'test'
+    
+    print("SUCCESS: FilePathField accepts callable path")
+    
+    # Test deconstruction
+    field = LocalFilesCallable._meta.get_field('file')
+    name, path, args, kwargs = field.deconstruct()
+    print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+    
+except Exception as e:
+    print(f"ERROR: FilePathField doesn't accept callable path: {e}")
+
+# Test with lambda
+print("\n=== Testing with lambda ===")
+try:
+    class LocalFilesLambda(models.Model):
+        name = models.CharField(max_length=255)
+        file = models.FilePathField(path=lambda: os.path.join(test_dir, 'example_dir'))
+        
+        class Meta:
+            app_label = 'test'
+    
+    print("SUCCESS: FilePathField accepts lambda path")
+    
+except Exception as e:
+    print(f"ERROR: FilePathField doesn't accept lambda path: {e}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file
diff --git a/test_deconstruct_issue.py b/test_deconstruct_issue.py
new file mode 100644
index 0000000000..c0f08042fc
--- /dev/null
+++ b/test_deconstruct_issue.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python
+"""
+Script to test the deconstruct issue with FilePathField callable paths.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create the example_dir
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+def get_file_path():
+    print(f"get_file_path() called! Returning: {os.path.join(test_dir, 'example_dir')}")
+    return os.path.join(test_dir, 'example_dir')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR=test_dir
+    )
+
+django.setup()
+
+print("\n=== Creating FilePathField with callable path ===")
+class LocalFiles(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=get_file_path)
+    
+    class Meta:
+        app_label = 'test'
+
+print("\n=== Testing deconstruction ===")
+field = LocalFiles._meta.get_field('file')
+print("About to call deconstruct()...")
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+print("\n=== Testing comparison in deconstruct ===")
+print(f"field.path: {field.path}")
+print(f"field.path != '': {field.path != ''}")
+print(f"type(field.path): {type(field.path)}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file
diff --git a/test_default_callable.py b/test_default_callable.py
new file mode 100644
index 0000000000..076f04f642
--- /dev/null
+++ b/test_default_callable.py
@@ -0,0 +1,49 @@
+#!/usr/bin/env python
+"""
+Script to test how callable defaults are handled in deconstruction.
+"""
+import django
+from django.conf import settings
+from django.db import models
+from datetime import datetime
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+print("=== Testing DateTimeField with callable default ===")
+class Article(models.Model):
+    headline = models.CharField(max_length=100, default='Default headline')
+    pub_date = models.DateTimeField(default=datetime.now)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test deconstruction
+field = Article._meta.get_field('pub_date')
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+# Test migration serialization
+from django.db.migrations.writer import MigrationWriter
+try:
+    writer = MigrationWriter(None)
+    serialized_kwargs = writer.serialize(kwargs)
+    print(f"Serialized kwargs: {serialized_kwargs}")
+except Exception as e:
+    print(f"ERROR: Cannot serialize kwargs for migration: {e}")
\ No newline at end of file
diff --git a/test_makemigrations.py b/test_makemigrations.py
new file mode 100644
index 0000000000..589cacddba
--- /dev/null
+++ b/test_makemigrations.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python
+"""
+Script to test makemigrations behavior with FilePathField callable paths.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+from django.core.management import call_command
+from django.apps import apps
+from django.db.migrations.writer import MigrationWriter
+from django.db.migrations.state import ProjectState
+from django.db.migrations.autodetector import MigrationAutodetector
+from io import StringIO
+import sys
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create the example_dir
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+def get_file_path():
+    return os.path.join(test_dir, 'example_dir')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'testapp',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR=test_dir
+    )
+
+django.setup()
+
+# Create a fake app config
+from django.apps import AppConfig
+class TestAppConfig(AppConfig):
+    name = 'testapp'
+    label = 'testapp'
+
+# Register the app
+apps.populate([TestAppConfig])
+
+print("\n=== Testing FilePathField with callable path ===")
+class LocalFiles(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=get_file_path)
+    
+    class Meta:
+        app_label = 'testapp'
+
+# Test deconstruction
+field = LocalFiles._meta.get_field('file')
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+# Test migration serialization
+try:
+    writer = MigrationWriter(None)
+    serialized_kwargs = writer.serialize(kwargs)
+    print(f"Serialized kwargs: {serialized_kwargs}")
+except Exception as e:
+    print(f"ERROR: Cannot serialize kwargs for migration: {e}")
+
+# Test autodetector
+print("\n=== Testing migration autodetector ===")
+try:
+    # Create project states
+    from_state = ProjectState()
+    to_state = ProjectState()
+    to_state.add_model(LocalFiles._meta)
+    
+    # Run autodetector
+    autodetector = MigrationAutodetector(from_state, to_state)
+    changes = autodetector.changes(graph=None)
+    
+    print(f"Detected changes: {changes}")
+    
+    if changes:
+        for app_label, migrations in changes.items():
+            for migration in migrations:
+                print(f"Migration operations: {migration.operations}")
+                for operation in migration.operations:
+                    if hasattr(operation, 'field'):
+                        field_name, field_path, field_args, field_kwargs = operation.field.deconstruct()
+                        print(f"Field deconstruct: name={field_name}, path={field_path}, args={field_args}, kwargs={field_kwargs}")
+                        
+                        # Try to serialize the field
+                        try:
+                            serialized_field = writer.serialize(operation.field)
+                            print(f"Serialized field: {serialized_field}")
+                        except Exception as e:
+                            print(f"ERROR serializing field: {e}")
+    
+except Exception as e:
+    print(f"ERROR in autodetector: {e}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file
diff --git a/test_migration_issue.py b/test_migration_issue.py
new file mode 100644
index 0000000000..835f18a6fa
--- /dev/null
+++ b/test_migration_issue.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python
+"""
+Script to test the migration issue with FilePathField callable paths.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+from django.db.migrations.writer import MigrationWriter
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR='/tmp/test_files'
+    )
+
+django.setup()
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create the example_dir
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+def get_file_path():
+    return os.path.join(test_dir, 'example_dir')
+
+print("\n=== Testing FilePathField with callable path ===")
+class LocalFilesCallable(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=get_file_path)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test deconstruction
+field = LocalFilesCallable._meta.get_field('file')
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+# Test if the deconstructed field can be serialized for migrations
+print("\n=== Testing migration serialization ===")
+try:
+    writer = MigrationWriter(None)
+    serialized_kwargs = writer.serialize(kwargs)
+    print(f"Serialized kwargs: {serialized_kwargs}")
+except Exception as e:
+    print(f"ERROR: Cannot serialize kwargs for migration: {e}")
+
+# Test what happens when we try to use the path in forms
+print("\n=== Testing form field creation ===")
+try:
+    form_field = field.formfield()
+    print(f"Form field created successfully: {form_field}")
+    print(f"Form field path: {form_field.path}")
+except Exception as e:
+    print(f"ERROR: Cannot create form field: {e}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file
diff --git a/test_pr_scenario.py b/test_pr_scenario.py
new file mode 100644
index 0000000000..81e9d590ab
--- /dev/null
+++ b/test_pr_scenario.py
@@ -0,0 +1,74 @@
+#!/usr/bin/env python
+"""
+Script to test the exact scenario described in the PR.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create the example_dir
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR=test_dir  # This is the key setting from the PR
+    )
+
+django.setup()
+
+print("\n=== Testing the exact scenario from the PR ===")
+# This is the exact code from the PR description
+class LocalFiles(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=os.path.join(settings.LOCAL_FILE_DIR, 'example_dir'))
+    
+    class Meta:
+        app_label = 'test'
+
+print("\n=== Testing deconstruction ===")
+field = LocalFiles._meta.get_field('file')
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+print(f"field.path: {field.path}")
+print(f"type(field.path): {type(field.path)}")
+
+# Test migration serialization
+from django.db.migrations.writer import MigrationWriter
+try:
+    writer = MigrationWriter(None)
+    serialized_kwargs = writer.serialize(kwargs)
+    print(f"Serialized kwargs: {serialized_kwargs}")
+    
+    # Test serializing the field itself
+    serialized_field = writer.serialize(field)
+    print(f"Serialized field: {serialized_field}")
+    
+except Exception as e:
+    print(f"ERROR: Cannot serialize for migration: {e}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file
diff --git a/test_simple_migration.py b/test_simple_migration.py
new file mode 100644
index 0000000000..41319326f3
--- /dev/null
+++ b/test_simple_migration.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python
+"""
+Script to test how FilePathField callable paths are handled in migrations.
+"""
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.db import models
+
+# Create a temporary directory for testing
+test_dir = tempfile.mkdtemp()
+print(f"Created test directory: {test_dir}")
+
+# Create the example_dir
+os.makedirs(os.path.join(test_dir, 'example_dir'), exist_ok=True)
+with open(os.path.join(test_dir, 'example_dir', 'test.txt'), 'w') as f:
+    f.write('test content')
+
+def get_file_path():
+    return os.path.join(test_dir, 'example_dir')
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR=test_dir
+    )
+
+django.setup()
+
+print("\n=== Testing FilePathField with callable path ===")
+class LocalFiles(models.Model):
+    name = models.CharField(max_length=255)
+    file = models.FilePathField(path=get_file_path)
+    
+    class Meta:
+        app_label = 'test'
+
+# Test deconstruction
+field = LocalFiles._meta.get_field('file')
+name, path, args, kwargs = field.deconstruct()
+print(f"Deconstruct result: name={name}, path={path}, args={args}, kwargs={kwargs}")
+
+# Test migration serialization
+from django.db.migrations.writer import MigrationWriter
+try:
+    writer = MigrationWriter(None)
+    serialized_kwargs = writer.serialize(kwargs)
+    print(f"Serialized kwargs: {serialized_kwargs}")
+    
+    # Test serializing the field itself
+    serialized_field = writer.serialize(field)
+    print(f"Serialized field: {serialized_field}")
+    
+except Exception as e:
+    print(f"ERROR: Cannot serialize for migration: {e}")
+
+# Test what happens when we create a new field from the deconstructed data
+print("\n=== Testing field reconstruction ===")
+try:
+    # Reconstruct the field
+    reconstructed_field = models.FilePathField(**kwargs)
+    print(f"Reconstructed field path: {reconstructed_field.path}")
+    print(f"Is path callable? {callable(reconstructed_field.path)}")
+    
+    if callable(reconstructed_field.path):
+        print(f"Calling path: {reconstructed_field.path()}")
+    
+except Exception as e:
+    print(f"ERROR reconstructing field: {e}")
+
+# Clean up
+import shutil
+shutil.rmtree(test_dir)
+print(f"\nCleaned up test directory: {test_dir}")
\ No newline at end of file

diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 0c64748ccd..57637fe5a4 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -1687,8 +1687,9 @@ class FilePathField(Field):
 
     def deconstruct(self):
         name, path, args, kwargs = super().deconstruct()
-        if self.path != '':
-            kwargs['path'] = self.path
+        resolved_path = self.path() if callable(self.path) else self.path
+        if resolved_path != '':
+            kwargs['path'] = resolved_path
         if self.match is not None:
             kwargs['match'] = self.match
         if self.recursive is not False:
@@ -1709,7 +1710,7 @@ class FilePathField(Field):
 
     def formfield(self, **kwargs):
         return super().formfield(**{
-            'path': self.path,
+            'path': self.path() if callable(self.path) else self.path,
             'match': self.match,
             'recursive': self.recursive,
             'form_class': forms.FilePathField,
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..f13a67ccdc
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR='/tmp/test_files'
+    )
+
+django.setup()
+
+from django.db import models
+
+def get_file_path():
+    """A callable that returns the file path"""
+    return os.path.join(settings.LOCAL_FILE_DIR, 'example_dir')
+
+class LocalFiles(models.Model):
+    name = models.CharField(max_length=255)
+    # This should work with a callable path
+    file = models.FilePathField(path=get_file_path)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_deconstruct():
+    """Test that deconstruct works with callable path"""
+    print("Testing FilePathField with callable path...")
+    
+    field = LocalFiles._meta.get_field('file')
+    print(f"Field path: {field.path}")
+    print(f"Is callable: {callable(field.path)}")
+    
+    # Test deconstruct - this should handle callable paths
+    try:
+        name, path, args, kwargs = field.deconstruct()
+        print(f"Deconstruct successful:")
+        print(f"  name: {name}")
+        print(f"  path: {path}")
+        print(f"  args: {args}")
+        print(f"  kwargs: {kwargs}")
+        
+        # Check if path in kwargs is correct
+        if 'path' in kwargs:
+            print(f"  path value: {kwargs['path']}")
+            print(f"  path type: {type(kwargs['path'])}")
+    except Exception as e:
+        print(f"Deconstruct failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+def test_formfield():
+    """Test that formfield works with callable path"""
+    print("\nTesting formfield with callable path...")
+    
+    # Create test directory
+    os.makedirs('/tmp/test_files/example_dir', exist_ok=True)
+    
+    field = LocalFiles._meta.get_field('file')
+    
+    try:
+        form_field = field.formfield()
+        print(f"Formfield successful:")
+        print(f"  form_field: {form_field}")
+        print(f"  form_field.path: {form_field.path}")
+    except Exception as e:
+        print(f"Formfield failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_deconstruct()
+    test_formfield()
\ No newline at end of file
diff --git a/test_callable_path.py b/test_callable_path.py
new file mode 100644
index 0000000000..cfe52ecffe
--- /dev/null
+++ b/test_callable_path.py
@@ -0,0 +1,132 @@
+#!/usr/bin/env python
+
+import os
+import tempfile
+import django
+from django.conf import settings
+from django.test import TestCase
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.test import SimpleTestCase
+
+class FilePathFieldCallableTests(SimpleTestCase):
+    """Test FilePathField with callable path parameter"""
+    
+    def setUp(self):
+        self.temp_dir = tempfile.mkdtemp()
+        self.test_file_path = os.path.join(self.temp_dir, 'test.txt')
+        with open(self.test_file_path, 'w') as f:
+            f.write('test content')
+    
+    def tearDown(self):
+        import shutil
+        shutil.rmtree(self.temp_dir, ignore_errors=True)
+    
+    def get_temp_dir(self):
+        """Callable that returns temp directory path"""
+        return self.temp_dir
+    
+    def get_empty_path(self):
+        """Callable that returns empty string"""
+        return ''
+    
+    def test_callable_path_deconstruct(self):
+        """Test that deconstruct resolves callable path to string"""
+        field = models.FilePathField(path=self.get_temp_dir)
+        
+        # Verify the field stores the callable
+        self.assertTrue(callable(field.path))
+        
+        # Test deconstruct
+        name, path, args, kwargs = field.deconstruct()
+        
+        # The path should be resolved to a string in kwargs
+        self.assertIn('path', kwargs)
+        self.assertEqual(kwargs['path'], self.temp_dir)
+        self.assertIsInstance(kwargs['path'], str)
+    
+    def test_string_path_deconstruct(self):
+        """Test that deconstruct still works with string path"""
+        field = models.FilePathField(path=self.temp_dir)
+        
+        # Verify the field stores the string
+        self.assertFalse(callable(field.path))
+        self.assertEqual(field.path, self.temp_dir)
+        
+        # Test deconstruct
+        name, path, args, kwargs = field.deconstruct()
+        
+        # The path should be the same string in kwargs
+        self.assertIn('path', kwargs)
+        self.assertEqual(kwargs['path'], self.temp_dir)
+        self.assertIsInstance(kwargs['path'], str)
+    
+    def test_empty_callable_path_deconstruct(self):
+        """Test that deconstruct works with callable returning empty string"""
+        field = models.FilePathField(path=self.get_empty_path)
+        
+        # Verify the field stores the callable
+        self.assertTrue(callable(field.path))
+        
+        # Test deconstruct
+        name, path, args, kwargs = field.deconstruct()
+        
+        # Empty path should not be included in kwargs
+        self.assertNotIn('path', kwargs)
+    
+    def test_callable_path_formfield(self):
+        """Test that formfield resolves callable path to string"""
+        field = models.FilePathField(path=self.get_temp_dir)
+        
+        # Test formfield creation
+        form_field = field.formfield()
+        
+        # The form field should have the resolved path
+        self.assertEqual(form_field.path, self.temp_dir)
+        self.assertIsInstance(form_field.path, str)
+    
+    def test_string_path_formfield(self):
+        """Test that formfield still works with string path"""
+        field = models.FilePathField(path=self.temp_dir)
+        
+        # Test formfield creation
+        form_field = field.formfield()
+        
+        # The form field should have the same path
+        self.assertEqual(form_field.path, self.temp_dir)
+        self.assertIsInstance(form_field.path, str)
+    
+    def test_callable_path_with_files(self):
+        """Test that callable path works with actual file operations"""
+        field = models.FilePathField(path=self.get_temp_dir, allow_files=True)
+        
+        # Test formfield creation and choices
+        form_field = field.formfield()
+        
+        # Should find our test file
+        choices = [choice[0] for choice in form_field.choices if choice[0]]  # Skip empty choice
+        self.assertIn(self.test_file_path, choices)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.main()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..2dd2e3cbc9
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,130 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR='/tmp/test_files'
+    )
+
+django.setup()
+
+from django.db import models
+
+def get_file_path():
+    """A callable that returns the file path"""
+    return os.path.join(settings.LOCAL_FILE_DIR, 'example_dir')
+
+def get_empty_path():
+    """A callable that returns empty string"""
+    return ''
+
+class TestModels(models.Model):
+    # Test with callable path
+    file_callable = models.FilePathField(path=get_file_path)
+    
+    # Test with string path (should still work)
+    file_string = models.FilePathField(path='/tmp/test_files/string_dir')
+    
+    # Test with empty string path
+    file_empty = models.FilePathField(path='')
+    
+    # Test with callable that returns empty string
+    file_callable_empty = models.FilePathField(path=get_empty_path)
+    
+    class Meta:
+        app_label = 'test'
+
+def test_all_scenarios():
+    """Test all scenarios"""
+    print("Testing all FilePathField scenarios...")
+    
+    # Create test directories
+    os.makedirs('/tmp/test_files/example_dir', exist_ok=True)
+    os.makedirs('/tmp/test_files/string_dir', exist_ok=True)
+    
+    # Test each field
+    fields = [
+        ('file_callable', 'callable path'),
+        ('file_string', 'string path'),
+        ('file_empty', 'empty string path'),
+        ('file_callable_empty', 'callable returning empty string'),
+    ]
+    
+    for field_name, description in fields:
+        print(f"\n--- Testing {description} ---")
+        field = TestModels._meta.get_field(field_name)
+        
+        print(f"Field path: {field.path}")
+        print(f"Is callable: {callable(field.path)}")
+        
+        # Test deconstruct
+        try:
+            name, path, args, kwargs = field.deconstruct()
+            print(f"Deconstruct successful:")
+            print(f"  kwargs: {kwargs}")
+            if 'path' in kwargs:
+                print(f"  path value: {repr(kwargs['path'])}")
+                print(f"  path type: {type(kwargs['path'])}")
+        except Exception as e:
+            print(f"Deconstruct failed: {e}")
+            import traceback
+            traceback.print_exc()
+        
+        # Test formfield (only if path is not empty)
+        try:
+            resolved_path = field.path() if callable(field.path) else field.path
+            if resolved_path:  # Only test formfield if path is not empty
+                form_field = field.formfield()
+                print(f"Formfield successful:")
+                print(f"  form_field.path: {form_field.path}")
+            else:
+                print("Skipping formfield test for empty path")
+        except Exception as e:
+            print(f"Formfield failed: {e}")
+            import traceback
+            traceback.print_exc()
+
+def test_migration_scenario():
+    """Test the migration scenario described in the PR"""
+    print("\n=== Testing Migration Scenario ===")
+    
+    # This simulates what happens during makemigrations
+    field = TestModels._meta.get_field('file_callable')
+    name, path, args, kwargs = field.deconstruct()
+    
+    print(f"Migration would generate:")
+    print(f"  Field name: {name}")
+    print(f"  Field class: {path}")
+    print(f"  Field args: {args}")
+    print(f"  Field kwargs: {kwargs}")
+    
+    # The key test: the path should be resolved to a string, not kept as a callable
+    if 'path' in kwargs:
+        path_value = kwargs['path']
+        if isinstance(path_value, str):
+            print("✓ SUCCESS: Path is resolved to string for migration")
+        else:
+            print(f"✗ FAILURE: Path is still {type(path_value)}: {path_value}")
+    else:
+        print("✓ Path is empty, which is fine")
+
+if __name__ == '__main__':
+    test_all_scenarios()
+    test_migration_scenario()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..1b24777a1c
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,114 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+        LOCAL_FILE_DIR='/tmp/test_files'
+    )
+
+django.setup()
+
+from django.db import models
+
+def get_path_with_args(*args, **kwargs):
+    """A callable that accepts arguments (should still work)"""
+    return '/tmp/test_files/args_dir'
+
+def get_path_that_raises():
+    """A callable that raises an exception"""
+    raise ValueError("Path calculation failed")
+
+def get_none_path():
+    """A callable that returns None"""
+    return None
+
+class EdgeCaseModels(models.Model):
+    # Test with callable that accepts arguments
+    file_with_args = models.FilePathField(path=get_path_with_args)
+    
+    # Test with lambda
+    file_lambda = models.FilePathField(path=lambda: '/tmp/test_files/lambda_dir')
+    
+    class Meta:
+        app_label = 'test'
+
+def test_edge_cases():
+    """Test edge cases"""
+    print("Testing edge cases...")
+    
+    # Test callable with arguments
+    print("\n--- Testing callable with arguments ---")
+    field = EdgeCaseModels._meta.get_field('file_with_args')
+    try:
+        name, path, args, kwargs = field.deconstruct()
+        print(f"Deconstruct successful: {kwargs}")
+        
+        # Create test directory
+        os.makedirs('/tmp/test_files/args_dir', exist_ok=True)
+        form_field = field.formfield()
+        print(f"Formfield successful: {form_field.path}")
+    except Exception as e:
+        print(f"Failed: {e}")
+        import traceback
+        traceback.print_exc()
+    
+    # Test lambda
+    print("\n--- Testing lambda ---")
+    field = EdgeCaseModels._meta.get_field('file_lambda')
+    try:
+        name, path, args, kwargs = field.deconstruct()
+        print(f"Deconstruct successful: {kwargs}")
+        
+        # Create test directory
+        os.makedirs('/tmp/test_files/lambda_dir', exist_ok=True)
+        form_field = field.formfield()
+        print(f"Formfield successful: {form_field.path}")
+    except Exception as e:
+        print(f"Failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+def test_error_cases():
+    """Test error cases"""
+    print("\n=== Testing Error Cases ===")
+    
+    # Test callable that raises exception
+    print("\n--- Testing callable that raises exception ---")
+    try:
+        field = models.FilePathField(path=get_path_that_raises)
+        name, path, args, kwargs = field.deconstruct()
+        print("This should have failed!")
+    except Exception as e:
+        print(f"Expected failure: {e}")
+    
+    # Test callable that returns None
+    print("\n--- Testing callable that returns None ---")
+    try:
+        field = models.FilePathField(path=get_none_path)
+        name, path, args, kwargs = field.deconstruct()
+        print(f"Deconstruct with None path: {kwargs}")
+    except Exception as e:
+        print(f"Failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_edge_cases()
+    test_error_cases()
\ No newline at end of file
diff --git a/test_none_formfield.py b/test_none_formfield.py
new file mode 100644
index 0000000000..70c001f204
--- /dev/null
+++ b/test_none_formfield.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_none_formfield():
+    """Test what happens with None path in formfield"""
+    print("Testing None path in formfield...")
+    
+    try:
+        field = models.FilePathField(path=None)
+        print(f"Field created with path=None: {field.path}")
+        
+        form_field = field.formfield()
+        print(f"Formfield created successfully: {form_field}")
+        print(f"Formfield path: {form_field.path}")
+        
+    except Exception as e:
+        print(f"Failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_none_formfield()
\ No newline at end of file
diff --git a/test_none_path.py b/test_none_path.py
new file mode 100644
index 0000000000..ad917a3e34
--- /dev/null
+++ b/test_none_path.py
@@ -0,0 +1,46 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+
+def test_none_path():
+    """Test what happens with None path"""
+    print("Testing None path...")
+    
+    try:
+        field = models.FilePathField(path=None)
+        print(f"Field created with path=None: {field.path}")
+        
+        name, path, args, kwargs = field.deconstruct()
+        print(f"Deconstruct: {kwargs}")
+        
+    except Exception as e:
+        print(f"Failed to create field with None path: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == '__main__':
+    test_none_path()
\ No newline at end of file

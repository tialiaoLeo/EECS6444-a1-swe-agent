diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 7649c39262..a307328024 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -353,7 +353,12 @@ class SQLCompiler:
             # not taken into account so we strip it. When this entire method
             # is refactored into expressions, then we can check each part as we
             # generate it.
-            without_ordering = self.ordering_parts.search(sql).group(1)
+            # Multiline ordering SQL clause may appear from RawSQL.
+            sql_oneline = ' '.join(sql.split())
+            match = self.ordering_parts.search(sql_oneline)
+            if not match:
+                raise ValueError('ORDER BY term does not contain ASC or DESC: %s' % sql)
+            without_ordering = match.group(1)
             params_hash = make_hashable(params)
             if (without_ordering, params_hash) in seen:
                 continue
@@ -366,7 +371,12 @@ class SQLCompiler:
         if self.query.distinct and not self.query.distinct_fields:
             select_sql = [t[1] for t in select]
             for expr, (sql, params, is_ref) in order_by:
-                without_ordering = self.ordering_parts.search(sql).group(1)
+                # Multiline ordering SQL clause may appear from RawSQL.
+                sql_oneline = ' '.join(sql.split())
+                match = self.ordering_parts.search(sql_oneline)
+                if not match:
+                    raise ValueError('ORDER BY term does not contain ASC or DESC: %s' % sql)
+                without_ordering = match.group(1)
                 if not is_ref and (without_ordering, params) not in select_sql:
                     extra_select.append((expr, (without_ordering, params), None))
         return extra_select
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..3c2e197169
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+
+# Create a simple model for testing
+class MyModel(models.Model):
+    status = models.CharField(max_length=20)
+    accepted_datetime = models.DateTimeField(null=True)
+    preferred_datetime = models.DateTimeField(null=True)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(MyModel)
+
+def test_multiline_rawsql_ordering():
+    """Test the issue with multiline RawSQL ordering"""
+    print("Testing multiline RawSQL ordering issue...")
+    
+    # Create the problematic query from the issue description
+    queryset = MyModel.objects.all().order_by(
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then 2 else 1 end''', []).desc(),
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime)
+                 else null end''', []).asc(),
+        RawSQL('''
+            case when status not in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime, created_at)
+                 else null end''', []).desc())
+    
+    # Get the SQL compiler
+    compiler = queryset.query.get_compiler('default')
+    
+    # Get the order by clauses
+    order_by_result = compiler.get_order_by()
+    
+    print(f"Number of order by clauses: {len(order_by_result)}")
+    print("Order by clauses:")
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_result):
+        print(f"  {i+1}: {sql}")
+    
+    # Test the regex pattern directly
+    print("\nTesting regex pattern directly:")
+    test_sql_multiline = '''
+            case when status in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime)
+                 else null end ASC'''
+    
+    test_sql_multiline2 = '''
+            case when status not in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime, created_at)
+                 else null end DESC'''
+    
+    import re
+    ordering_parts = re.compile(r'(.*)\s(ASC|DESC)(.*)')
+    
+    # Test with original multiline SQL (problematic)
+    match1 = ordering_parts.search(test_sql_multiline)
+    match2 = ordering_parts.search(test_sql_multiline2)
+    
+    if match1:
+        print(f"Match 1 group(1) (multiline): '{match1.group(1)}'")
+    if match2:
+        print(f"Match 2 group(1) (multiline): '{match2.group(1)}'")
+    
+    # Show that both matches return the same group(1) due to the regex issue
+    if match1 and match2:
+        print(f"Are they equal (multiline)? {match1.group(1) == match2.group(1)}")
+    
+    # Test with normalized SQL (fixed)
+    sql1_oneline = ' '.join(test_sql_multiline.split())
+    sql2_oneline = ' '.join(test_sql_multiline2.split())
+    
+    match1_fixed = ordering_parts.search(sql1_oneline)
+    match2_fixed = ordering_parts.search(sql2_oneline)
+    
+    if match1_fixed:
+        print(f"Match 1 group(1) (normalized): '{match1_fixed.group(1)}'")
+    if match2_fixed:
+        print(f"Match 2 group(1) (normalized): '{match2_fixed.group(1)}'")
+    
+    if match1_fixed and match2_fixed:
+        print(f"Are they equal (normalized)? {match1_fixed.group(1) == match2_fixed.group(1)}")
+
+if __name__ == '__main__':
+    test_multiline_rawsql_ordering()
\ No newline at end of file
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..690e1395ac
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+
+# Create a simple model for testing
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=20)
+    priority = models.IntegerField(default=0)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+def test_comprehensive_scenarios():
+    """Test various scenarios with multiline RawSQL ordering"""
+    print("Testing comprehensive scenarios...")
+    
+    # Test 1: Original issue - multiline RawSQL with similar endings
+    print("\n1. Testing original issue scenario:")
+    queryset1 = TestModel.objects.all().order_by(
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then 2 else 1 end''', []).desc(),
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then priority
+                 else null end''', []).asc(),
+        RawSQL('''
+            case when status not in ('accepted', 'verification')
+                 then priority
+                 else null end''', []).desc())
+    
+    compiler1 = queryset1.query.get_compiler('default')
+    order_by1 = compiler1.get_order_by()
+    print(f"  Number of order by clauses: {len(order_by1)} (expected: 3)")
+    assert len(order_by1) == 3, f"Expected 3 order by clauses, got {len(order_by1)}"
+    
+    # Test 2: Single line RawSQL (should work as before)
+    print("\n2. Testing single line RawSQL:")
+    queryset2 = TestModel.objects.all().order_by(
+        RawSQL('priority', []).desc(),
+        RawSQL('name', []).asc(),
+        RawSQL('priority', []).desc())  # Duplicate should be removed
+    
+    compiler2 = queryset2.query.get_compiler('default')
+    order_by2 = compiler2.get_order_by()
+    print(f"  Number of order by clauses: {len(order_by2)} (expected: 2, duplicate removed)")
+    assert len(order_by2) == 2, f"Expected 2 order by clauses, got {len(order_by2)}"
+    
+    # Test 3: Mixed single line and multiline
+    print("\n3. Testing mixed single line and multiline:")
+    queryset3 = TestModel.objects.all().order_by(
+        RawSQL('priority', []).desc(),
+        RawSQL('''
+            case when status = 'active'
+                 then priority
+                 else 0 end''', []).asc(),
+        RawSQL('name', []).asc())
+    
+    compiler3 = queryset3.query.get_compiler('default')
+    order_by3 = compiler3.get_order_by()
+    print(f"  Number of order by clauses: {len(order_by3)} (expected: 3)")
+    assert len(order_by3) == 3, f"Expected 3 order by clauses, got {len(order_by3)}"
+    
+    # Test 4: Multiline with different whitespace types
+    print("\n4. Testing multiline with different whitespace types:")
+    queryset4 = TestModel.objects.all().order_by(
+        RawSQL('''case when status = 'active'
+\t\t\t\tthen priority
+\t\t\t\telse 0 end''', []).desc(),
+        RawSQL('''case when status = 'inactive'\r\n                 then priority\r\n                 else 0 end''', []).asc())
+    
+    compiler4 = queryset4.query.get_compiler('default')
+    order_by4 = compiler4.get_order_by()
+    print(f"  Number of order by clauses: {len(order_by4)} (expected: 2)")
+    assert len(order_by4) == 2, f"Expected 2 order by clauses, got {len(order_by4)}"
+    
+    # Test 5: Verify actual SQL generation
+    print("\n5. Testing actual SQL generation:")
+    queryset5 = TestModel.objects.all().order_by(
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then priority else 0 end''', []).desc())
+    
+    sql5 = str(queryset5.query)
+    print(f"  Generated SQL contains ORDER BY: {'ORDER BY' in sql5}")
+    print(f"  Generated SQL: {sql5}")
+    assert 'ORDER BY' in sql5, "Generated SQL should contain ORDER BY clause"
+    
+    print("\nAll tests passed! ✅")
+
+if __name__ == '__main__':
+    test_comprehensive_scenarios()
\ No newline at end of file
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..b63c44cd22
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python
+
+import re
+
+def test_edge_cases():
+    """Test edge cases for the multiline SQL fix"""
+    ordering_parts = re.compile(r'(.*)\s(ASC|DESC)(.*)')
+    
+    test_cases = [
+        # Normal cases
+        ("SELECT * FROM table ORDER BY column ASC", "SELECT * FROM table ORDER BY column"),
+        ("SELECT * FROM table ORDER BY column DESC", "SELECT * FROM table ORDER BY column"),
+        
+        # Multiline cases
+        ("""SELECT * FROM table 
+            ORDER BY column ASC""", "SELECT * FROM table ORDER BY column"),
+        
+        ("""SELECT * FROM table
+            ORDER BY 
+                CASE WHEN status = 'active' 
+                     THEN priority 
+                     ELSE 0 
+                END ASC""", "SELECT * FROM table ORDER BY CASE WHEN status = 'active' THEN priority ELSE 0 END"),
+        
+        # Edge cases
+        ("", None),  # Empty string
+        ("   ", None),  # Only whitespace
+        ("SELECT * FROM table", None),  # No ASC/DESC
+        ("ASC", ""),  # Only ASC
+        ("DESC", ""),  # Only DESC
+        ("column ASC extra", "column"),  # Extra content after ASC/DESC
+        
+        # Multiple ASC/DESC (should match first one)
+        ("col1 ASC, col2 DESC", "col1"),
+        
+        # Different whitespace types
+        ("column\tASC", "column"),  # Tab
+        ("column\r\nASC", "column"),  # Windows line ending
+        ("column\nASC", "column"),  # Unix line ending
+        
+        # Complex multiline with various whitespace
+        ("""
+            CASE 
+                WHEN status IN ('accepted', 'verification')
+                THEN priority
+                ELSE 0
+            END ASC
+        """, "CASE WHEN status IN ('accepted', 'verification') THEN priority ELSE 0 END"),
+    ]
+    
+    print("Testing edge cases for multiline SQL normalization:")
+    print("=" * 60)
+    
+    for i, (sql, expected_without_ordering) in enumerate(test_cases, 1):
+        print(f"\nTest case {i}:")
+        print(f"Input SQL: {repr(sql)}")
+        
+        # Test with original approach (problematic for multiline)
+        match_original = ordering_parts.search(sql)
+        if match_original:
+            without_ordering_original = match_original.group(1)
+            print(f"Original regex result: {repr(without_ordering_original)}")
+        else:
+            without_ordering_original = None
+            print("Original regex result: No match")
+        
+        # Test with normalized approach (our fix)
+        if sql.strip():  # Only process non-empty strings
+            sql_oneline = ' '.join(sql.split())
+            match_normalized = ordering_parts.search(sql_oneline)
+            if match_normalized:
+                without_ordering_normalized = match_normalized.group(1)
+                print(f"Normalized regex result: {repr(without_ordering_normalized)}")
+            else:
+                without_ordering_normalized = None
+                print("Normalized regex result: No match")
+        else:
+            without_ordering_normalized = None
+            print("Normalized regex result: Empty input, no processing")
+        
+        # Check if result matches expectation
+        if expected_without_ordering is None:
+            expected_result = without_ordering_normalized is None
+        else:
+            expected_result = without_ordering_normalized == expected_without_ordering
+        
+        print(f"Expected: {repr(expected_without_ordering)}")
+        print(f"Test {'PASSED' if expected_result else 'FAILED'}")
+        
+        if not expected_result:
+            print(f"  Expected: {repr(expected_without_ordering)}")
+            print(f"  Got: {repr(without_ordering_normalized)}")
+
+if __name__ == '__main__':
+    test_edge_cases()
\ No newline at end of file
diff --git a/test_split_behavior.py b/test_split_behavior.py
new file mode 100644
index 0000000000..18b5ea5d64
--- /dev/null
+++ b/test_split_behavior.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python
+
+def test_split_behavior():
+    """Test how str.split() behaves with different inputs"""
+    
+    test_cases = [
+        "",
+        "   ",
+        "hello world",
+        "hello\tworld",
+        "hello\nworld",
+        "hello\r\nworld",
+        "  hello   world  ",
+        "\n\thello\r\n  world\t\n",
+    ]
+    
+    print("Testing str.split() behavior:")
+    print("=" * 40)
+    
+    for sql in test_cases:
+        print(f"\nInput: {repr(sql)}")
+        split_result = sql.split()
+        joined_result = ' '.join(split_result)
+        print(f"split(): {split_result}")
+        print(f"' '.join(split()): {repr(joined_result)}")
+        print(f"Empty after normalization: {not joined_result.strip()}")
+
+if __name__ == '__main__':
+    test_split_behavior()
\ No newline at end of file

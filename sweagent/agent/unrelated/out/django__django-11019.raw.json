{
  "instance_id": "django__django-11019",
  "variant": "oracle",
  "split": "test",
  "meta": {
    "instance_id": "django__django-11019",
    "repo": "django/django",
    "base_commit": "93e892bb645b16ebaf287beb5fe7f3ffe8d10408",
    "patch": "<patch>\ndiff --git a/django/forms/widgets.py b/django/forms/widgets.py\n--- a/django/forms/widgets.py\n+++ b/django/forms/widgets.py\n@@ -6,16 +6,21 @@\n import datetime\n import re\n import warnings\n+from collections import defaultdict\n from itertools import chain\n \n from django.conf import settings\n from django.forms.utils import to_current_timezone\n from django.templatetags.static import static\n from django.utils import datetime_safe, formats\n+from django.utils.datastructures import OrderedSet\n from django.utils.dates import MONTHS\n from django.utils.formats import get_format\n from django.utils.html import format_html, html_safe\n from django.utils.safestring import mark_safe\n+from django.utils.topological_sort import (\n+    CyclicDependencyError, stable_topological_sort,\n+)\n from django.utils.translation import gettext_lazy as _\n \n from .renderers import get_default_renderer\n@@ -59,22 +64,15 @@ def __str__(self):\n \n     @property\n     def _css(self):\n-        css = self._css_lists[0]\n-        # filter(None, ...) avoids calling merge with empty dicts.\n-        for obj in filter(None, self._css_lists[1:]):\n-            css = {\n-                medium: self.merge(css.get(medium, []), obj.get(medium, []))\n-                for medium in css.keys() | obj.keys()\n-            }\n-        return css\n+        css = defaultdict(list)\n+        for css_list in self._css_lists:\n+            for medium, sublist in css_list.items():\n+                css[medium].append(sublist)\n+        return {medium: self.merge(*lists) for medium, lists in css.items()}\n \n     @property\n     def _js(self):\n-        js = self._js_lists[0]\n-        # filter(None, ...) avoids calling merge() with empty lists.\n-        for obj in filter(None, self._js_lists[1:]):\n-            js = self.merge(js, obj)\n-        return js\n+        return self.merge(*self._js_lists)\n \n     def render(self):\n         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n@@ -115,39 +113,37 @@ def __getitem__(self, name):\n         raise KeyError('Unknown media type \"%s\"' % name)\n \n     @staticmethod\n-    def merge(list_1, list_2):\n+    def merge(*lists):\n         \"\"\"\n-        Merge two lists while trying to keep the relative order of the elements.\n-        Warn if the lists have the same two elements in a different relative\n-        order.\n+        Merge lists while trying to keep the relative order of the elements.\n+        Warn if the lists have the same elements in a different relative order.\n \n         For static assets it can be important to have them included in the DOM\n         in a certain order. In JavaScript you may not be able to reference a\n         global or in CSS you might want to override a style.\n         \"\"\"\n-        # Start with a copy of list_1.\n-        combined_list = list(list_1)\n-        last_insert_index = len(list_1)\n-        # Walk list_2 in reverse, inserting each element into combined_list if\n-        # it doesn't already exist.\n-        for path in reversed(list_2):\n-            try:\n-                # Does path already exist in the list?\n-                index = combined_list.index(path)\n-            except ValueError:\n-                # Add path to combined_list since it doesn't exist.\n-                combined_list.insert(last_insert_index, path)\n-            else:\n-                if index > last_insert_index:\n-                    warnings.warn(\n-                        'Detected duplicate Media files in an opposite order:\\n'\n-                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n-                        MediaOrderConflictWarning,\n-                    )\n-                # path already exists in the list. Update last_insert_index so\n-                # that the following elements are inserted in front of this one.\n-                last_insert_index = index\n-        return combined_list\n+        dependency_graph = defaultdict(set)\n+        all_items = OrderedSet()\n+        for list_ in filter(None, lists):\n+            head = list_[0]\n+            # The first items depend on nothing but have to be part of the\n+            # dependency graph to be included in the result.\n+            dependency_graph.setdefault(head, set())\n+            for item in list_:\n+                all_items.add(item)\n+                # No self dependencies\n+                if head != item:\n+                    dependency_graph[item].add(head)\n+                head = item\n+        try:\n+            return stable_topological_sort(all_items, dependency_graph)\n+        except CyclicDependencyError:\n+            warnings.warn(\n+                'Detected duplicate Media files in an opposite order: {}'.format(\n+                    ', '.join(repr(l) for l in lists)\n+                ), MediaOrderConflictWarning,\n+            )\n+            return list(all_items)\n \n     def __add__(self, other):\n         combined = Media()\n\n</patch>",
    "test_patch": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -497,10 +497,10 @@ def test_inline_media_only_inline(self):\n             response.context['inline_admin_formsets'][0].media._js,\n             [\n                 'admin/js/vendor/jquery/jquery.min.js',\n-                'admin/js/jquery.init.js',\n-                'admin/js/inlines.min.js',\n                 'my_awesome_inline_scripts.js',\n                 'custom_number.js',\n+                'admin/js/jquery.init.js',\n+                'admin/js/inlines.min.js',\n             ]\n         )\n         self.assertContains(response, 'my_awesome_inline_scripts.js')\ndiff --git a/tests/admin_widgets/test_autocomplete_widget.py b/tests/admin_widgets/test_autocomplete_widget.py\n--- a/tests/admin_widgets/test_autocomplete_widget.py\n+++ b/tests/admin_widgets/test_autocomplete_widget.py\n@@ -139,4 +139,4 @@ def test_media(self):\n                 else:\n                     expected_files = base_files\n                 with translation.override(lang):\n-                    self.assertEqual(AutocompleteSelect(rel, admin.site).media._js, expected_files)\n+                    self.assertEqual(AutocompleteSelect(rel, admin.site).media._js, list(expected_files))\ndiff --git a/tests/forms_tests/tests/test_media.py b/tests/forms_tests/tests/test_media.py\n--- a/tests/forms_tests/tests/test_media.py\n+++ b/tests/forms_tests/tests/test_media.py\n@@ -25,8 +25,8 @@ def test_construction(self):\n         )\n         self.assertEqual(\n             repr(m),\n-            \"Media(css={'all': ('path/to/css1', '/path/to/css2')}, \"\n-            \"js=('/path/to/js1', 'http://media.other.com/path/to/js2', 'https://secure.other.com/path/to/js3'))\"\n+            \"Media(css={'all': ['path/to/css1', '/path/to/css2']}, \"\n+            \"js=['/path/to/js1', 'http://media.other.com/path/to/js2', 'https://secure.other.com/path/to/js3'])\"\n         )\n \n         class Foo:\n@@ -125,8 +125,8 @@ class Media:\n <link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n         # media addition hasn't affected the original objects\n@@ -151,6 +151,17 @@ class Media:\n         self.assertEqual(str(w4.media), \"\"\"<link href=\"/path/to/css1\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\"\"\")\n \n+    def test_media_deduplication(self):\n+        # A deduplication test applied directly to a Media object, to confirm\n+        # that the deduplication doesn't only happen at the point of merging\n+        # two or more media objects.\n+        media = Media(\n+            css={'all': ('/path/to/css1', '/path/to/css1')},\n+            js=('/path/to/js1', '/path/to/js1'),\n+        )\n+        self.assertEqual(str(media), \"\"\"<link href=\"/path/to/css1\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n+<script type=\"text/javascript\" src=\"/path/to/js1\"></script>\"\"\")\n+\n     def test_media_property(self):\n         ###############################################################\n         # Property-based media definitions\n@@ -197,12 +208,12 @@ def _media(self):\n         self.assertEqual(\n             str(w6.media),\n             \"\"\"<link href=\"http://media.example.com/static/path/to/css1\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n-<link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <link href=\"/other/path\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n+<link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n+<script type=\"text/javascript\" src=\"/other/js\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/other/js\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n     def test_media_inheritance(self):\n@@ -247,8 +258,8 @@ class Media:\n <link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n     def test_media_inheritance_from_property(self):\n@@ -322,8 +333,8 @@ class Media:\n <link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n     def test_media_inheritance_single_type(self):\n@@ -420,8 +431,8 @@ def __init__(self, attrs=None):\n <link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n     def test_form_media(self):\n@@ -462,8 +473,8 @@ class MyForm(Form):\n <link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n         # Form media can be combined to produce a single media definition.\n@@ -477,8 +488,8 @@ class AnotherForm(Form):\n <link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n-<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n         # Forms can also define media, following the same rules as widgets.\n@@ -495,28 +506,28 @@ class Media:\n         self.assertEqual(\n             str(f3.media),\n             \"\"\"<link href=\"http://media.example.com/static/path/to/css1\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n+<link href=\"/some/form/css\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n-<link href=\"/some/form/css\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n+<script type=\"text/javascript\" src=\"/some/form/javascript\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n <script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n-<script type=\"text/javascript\" src=\"/some/form/javascript\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n         )\n \n         # Media works in templates\n         self.assertEqual(\n             Template(\"{{ form.media.js }}{{ form.media.css }}\").render(Context({'form': f3})),\n             \"\"\"<script type=\"text/javascript\" src=\"/path/to/js1\"></script>\n+<script type=\"text/javascript\" src=\"/some/form/javascript\"></script>\n <script type=\"text/javascript\" src=\"http://media.other.com/path/to/js2\"></script>\n-<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\n <script type=\"text/javascript\" src=\"/path/to/js4\"></script>\n-<script type=\"text/javascript\" src=\"/some/form/javascript\"></script>\"\"\"\n+<script type=\"text/javascript\" src=\"https://secure.other.com/path/to/js3\"></script>\"\"\"\n             \"\"\"<link href=\"http://media.example.com/static/path/to/css1\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n+<link href=\"/some/form/css\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n <link href=\"/path/to/css2\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n-<link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\n-<link href=\"/some/form/css\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\"\"\"\n+<link href=\"/path/to/css3\" type=\"text/css\" media=\"all\" rel=\"stylesheet\">\"\"\"\n         )\n \n     def test_html_safe(self):\n@@ -526,19 +537,23 @@ def test_html_safe(self):\n \n     def test_merge(self):\n         test_values = (\n-            (([1, 2], [3, 4]), [1, 2, 3, 4]),\n+            (([1, 2], [3, 4]), [1, 3, 2, 4]),\n             (([1, 2], [2, 3]), [1, 2, 3]),\n             (([2, 3], [1, 2]), [1, 2, 3]),\n             (([1, 3], [2, 3]), [1, 2, 3]),\n             (([1, 2], [1, 3]), [1, 2, 3]),\n             (([1, 2], [3, 2]), [1, 3, 2]),\n+            (([1, 2], [1, 2]), [1, 2]),\n+            ([[1, 2], [1, 3], [2, 3], [5, 7], [5, 6], [6, 7, 9], [8, 9]], [1, 5, 8, 2, 6, 3, 7, 9]),\n+            ((), []),\n+            (([1, 2],), [1, 2]),\n         )\n-        for (list1, list2), expected in test_values:\n-            with self.subTest(list1=list1, list2=list2):\n-                self.assertEqual(Media.merge(list1, list2), expected)\n+        for lists, expected in test_values:\n+            with self.subTest(lists=lists):\n+                self.assertEqual(Media.merge(*lists), expected)\n \n     def test_merge_warning(self):\n-        msg = 'Detected duplicate Media files in an opposite order:\\n1\\n2'\n+        msg = 'Detected duplicate Media files in an opposite order: [1, 2], [2, 1]'\n         with self.assertWarnsMessage(RuntimeWarning, msg):\n             self.assertEqual(Media.merge([1, 2], [2, 1]), [1, 2])\n \n@@ -546,28 +561,30 @@ def test_merge_js_three_way(self):\n         \"\"\"\n         The relative order of scripts is preserved in a three-way merge.\n         \"\"\"\n-        # custom_widget.js doesn't depend on jquery.js.\n-        widget1 = Media(js=['custom_widget.js'])\n-        widget2 = Media(js=['jquery.js', 'uses_jquery.js'])\n-        form_media = widget1 + widget2\n-        # The relative ordering of custom_widget.js and jquery.js has been\n-        # established (but without a real need to).\n-        self.assertEqual(form_media._js, ['custom_widget.js', 'jquery.js', 'uses_jquery.js'])\n-        # The inline also uses custom_widget.js. This time, it's at the end.\n-        inline_media = Media(js=['jquery.js', 'also_jquery.js']) + Media(js=['custom_widget.js'])\n-        merged = form_media + inline_media\n-        self.assertEqual(merged._js, ['custom_widget.js', 'jquery.js', 'uses_jquery.js', 'also_jquery.js'])\n+        widget1 = Media(js=['color-picker.js'])\n+        widget2 = Media(js=['text-editor.js'])\n+        widget3 = Media(js=['text-editor.js', 'text-editor-extras.js', 'color-picker.js'])\n+        merged = widget1 + widget2 + widget3\n+        self.assertEqual(merged._js, ['text-editor.js', 'text-editor-extras.js', 'color-picker.js'])\n+\n+    def test_merge_js_three_way2(self):\n+        # The merge prefers to place 'c' before 'b' and 'g' before 'h' to\n+        # preserve the original order. The preference 'c'->'b' is overridden by\n+        # widget3's media, but 'g'->'h' survives in the final ordering.\n+        widget1 = Media(js=['a', 'c', 'f', 'g', 'k'])\n+        widget2 = Media(js=['a', 'b', 'f', 'h', 'k'])\n+        widget3 = Media(js=['b', 'c', 'f', 'k'])\n+        merged = widget1 + widget2 + widget3\n+        self.assertEqual(merged._js, ['a', 'b', 'c', 'f', 'g', 'h', 'k'])\n \n     def test_merge_css_three_way(self):\n-        widget1 = Media(css={'screen': ['a.css']})\n-        widget2 = Media(css={'screen': ['b.css']})\n-        widget3 = Media(css={'all': ['c.css']})\n-        form1 = widget1 + widget2\n-        form2 = widget2 + widget1\n-        # form1 and form2 have a.css and b.css in different order...\n-        self.assertEqual(form1._css, {'screen': ['a.css', 'b.css']})\n-        self.assertEqual(form2._css, {'screen': ['b.css', 'a.css']})\n-        # ...but merging succeeds as the relative ordering of a.css and b.css\n-        # was never specified.\n-        merged = widget3 + form1 + form2\n-        self.assertEqual(merged._css, {'screen': ['a.css', 'b.css'], 'all': ['c.css']})\n+        widget1 = Media(css={'screen': ['c.css'], 'all': ['d.css', 'e.css']})\n+        widget2 = Media(css={'screen': ['a.css']})\n+        widget3 = Media(css={'screen': ['a.css', 'b.css', 'c.css'], 'all': ['e.css']})\n+        merged = widget1 + widget2\n+        # c.css comes before a.css because widget1 + widget2 establishes this\n+        # order.\n+        self.assertEqual(merged._css, {'screen': ['c.css', 'a.css'], 'all': ['d.css', 'e.css']})\n+        merged = merged + widget3\n+        # widget3 contains an explicit ordering of c.css and a.css.\n+        self.assertEqual(merged._css, {'screen': ['a.css', 'b.css', 'c.css'], 'all': ['d.css', 'e.css']})\n",
    "created_at": "2019-02-23T15:51:14Z",
    "version": "3.0",
    "FAIL_TO_PASS": "[\"test_combine_media (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_construction (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_form_media (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_deduplication (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_inheritance (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_inheritance_extends (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_property_parent_references (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_merge (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_merge_css_three_way (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_merge_js_three_way (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_merge_js_three_way2 (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_merge_warning (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_multi_widget (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_render_options (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_inline_media_only_inline (admin_inlines.tests.TestInlineMedia)\"]",
    "PASS_TO_PASS": "[\"Regression for #9362\", \"test_html_safe (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_dsl (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_inheritance_from_property (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_inheritance_single_type (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_media_property (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_multi_media (forms_tests.tests.test_media.FormsMediaTestCase)\", \"test_build_attrs (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_build_attrs_no_custom_class (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_build_attrs_not_required_field (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_build_attrs_required_field (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"test_get_url (admin_widgets.test_autocomplete_widget.AutocompleteMixinTests)\", \"Empty option isn't present if the field isn't required.\", \"Empty option is present if the field isn't required.\", \"test_deleting_inline_with_protected_delete_does_not_validate (admin_inlines.tests.TestInlineProtectedOnDelete)\", \"test_all_inline_media (admin_inlines.tests.TestInlineMedia)\", \"test_inline_media_only_base (admin_inlines.tests.TestInlineMedia)\", \"test_inline_add_fk_add_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_add_fk_noperm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_add_m2m_add_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_add_m2m_noperm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_add_change_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_add_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_all_perms (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_change_del_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_change_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_fk_noperm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_m2m_add_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_m2m_change_perm (admin_inlines.tests.TestInlinePermissions)\", \"test_inline_change_m2m_noperm (admin_inlines.tests.TestInlinePermissions)\", \"Admin inline should invoke local callable when its name is listed in readonly_fields\", \"test_can_delete (admin_inlines.tests.TestInline)\", \"test_create_inlines_on_inherited_model (admin_inlines.tests.TestInline)\", \"test_custom_form_tabular_inline_label (admin_inlines.tests.TestInline)\", \"test_custom_form_tabular_inline_overridden_label (admin_inlines.tests.TestInline)\", \"test_custom_get_extra_form (admin_inlines.tests.TestInline)\", \"test_custom_min_num (admin_inlines.tests.TestInline)\", \"test_custom_pk_shortcut (admin_inlines.tests.TestInline)\", \"test_help_text (admin_inlines.tests.TestInline)\", \"test_inline_editable_pk (admin_inlines.tests.TestInline)\", \"#18263 -- Make sure hidden fields don't get a column in tabular inlines\", \"test_inline_nonauto_noneditable_inherited_pk (admin_inlines.tests.TestInline)\", \"test_inline_nonauto_noneditable_pk (admin_inlines.tests.TestInline)\", \"test_inline_primary (admin_inlines.tests.TestInline)\", \"Inlines `show_change_link` for registered models when enabled.\", \"Inlines `show_change_link` disabled for unregistered models.\", \"test_localize_pk_shortcut (admin_inlines.tests.TestInline)\", \"Autogenerated many-to-many inlines are displayed correctly (#13407)\", \"test_min_num (admin_inlines.tests.TestInline)\", \"Admin inline `readonly_field` shouldn't invoke parent ModelAdmin callable\", \"test_non_related_name_inline (admin_inlines.tests.TestInline)\", \"Inlines without change permission shows field inputs on add form.\", \"Bug #13174.\", \"test_stacked_inline_edit_form_contains_has_original_class (admin_inlines.tests.TestInline)\", \"test_tabular_inline_column_css_class (admin_inlines.tests.TestInline)\", \"Inlines `show_change_link` disabled by default.\", \"test_tabular_model_form_meta_readonly_field (admin_inlines.tests.TestInline)\", \"test_tabular_non_field_errors (admin_inlines.tests.TestInline)\"]"
  },
  "text": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nMerging 3 or more media objects can throw unnecessary MediaOrderConflictWarnings\nDescription\n\t\nConsider the following form definition, where text-editor-extras.js depends on text-editor.js but all other JS files are independent:\nfrom django import forms\nclass ColorPicker(forms.Widget):\n\tclass Media:\n\t\tjs = ['color-picker.js']\nclass SimpleTextWidget(forms.Widget):\n\tclass Media:\n\t\tjs = ['text-editor.js']\nclass FancyTextWidget(forms.Widget):\n\tclass Media:\n\t\tjs = ['text-editor.js', 'text-editor-extras.js', 'color-picker.js']\nclass MyForm(forms.Form):\n\tbackground_color = forms.CharField(widget=ColorPicker())\n\tintro = forms.CharField(widget=SimpleTextWidget())\n\tbody = forms.CharField(widget=FancyTextWidget())\nDjango should be able to resolve the JS files for the final form into the order text-editor.js, text-editor-extras.js, color-picker.js. However, accessing MyForm().media results in:\n/projects/django/django/forms/widgets.py:145: MediaOrderConflictWarning: Detected duplicate Media files in an opposite order:\ntext-editor-extras.js\ntext-editor.js\n MediaOrderConflictWarning,\nMedia(css={}, js=['text-editor-extras.js', 'color-picker.js', 'text-editor.js'])\nThe MediaOrderConflictWarning is a result of the order that the additions happen in: ColorPicker().media + SimpleTextWidget().media produces Media(css={}, js=['color-picker.js', 'text-editor.js']), which (wrongly) imposes the constraint that color-picker.js must appear before text-editor.js.\nThe final result is particularly unintuitive here, as it's worse than the \"na√Øve\" result produced by Django 1.11 before order-checking was added (color-picker.js, text-editor.js, text-editor-extras.js), and the pair of files reported in the warning message seems wrong too (aren't color-picker.js and text-editor.js the wrong-ordered ones?)\n\n</issue>\n<code>\n[start of README.rst]\n1 Django is a high-level Python Web framework that encourages rapid development\n2 and clean, pragmatic design. Thanks for checking it out.\n3 \n4 All documentation is in the \"``docs``\" directory and online at\n5 https://docs.djangoproject.com/en/stable/. If you're just getting started,\n6 here's how we recommend you read the docs:\n7 \n8 * First, read ``docs/intro/install.txt`` for instructions on installing Django.\n9 \n10 * Next, work through the tutorials in order (``docs/intro/tutorial01.txt``,\n11   ``docs/intro/tutorial02.txt``, etc.).\n12 \n13 * If you want to set up an actual deployment server, read\n14   ``docs/howto/deployment/index.txt`` for instructions.\n15 \n16 * You'll probably want to read through the topical guides (in ``docs/topics``)\n17   next; from there you can jump to the HOWTOs (in ``docs/howto``) for specific\n18   problems, and check out the reference (``docs/ref``) for gory details.\n19 \n20 * See ``docs/README`` for instructions on building an HTML version of the docs.\n21 \n22 Docs are updated rigorously. If you find any problems in the docs, or think\n23 they should be clarified in any way, please take 30 seconds to fill out a\n24 ticket here: https://code.djangoproject.com/newticket\n25 \n26 To get more help:\n27 \n28 * Join the ``#django`` channel on irc.freenode.net. Lots of helpful people hang\n29   out there. See https://en.wikipedia.org/wiki/Wikipedia:IRC/Tutorial if you're\n30   new to IRC.\n31 \n32 * Join the django-users mailing list, or read the archives, at\n33   https://groups.google.com/group/django-users.\n34 \n35 To contribute to Django:\n36 \n37 * Check out https://docs.djangoproject.com/en/dev/internals/contributing/ for\n38   information about getting involved.\n39 \n40 To run Django's test suite:\n41 \n42 * Follow the instructions in the \"Unit tests\" section of\n43   ``docs/internals/contributing/writing-code/unit-tests.txt``, published online at\n44   https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/unit-tests/#running-the-unit-tests\n45 \n[end of README.rst]\n[start of django/forms/widgets.py]\n1 \"\"\"\n2 HTML Widget classes\n3 \"\"\"\n4 \n5 import copy\n6 import datetime\n7 import re\n8 import warnings\n9 from itertools import chain\n10 \n11 from django.conf import settings\n12 from django.forms.utils import to_current_timezone\n13 from django.templatetags.static import static\n14 from django.utils import datetime_safe, formats\n15 from django.utils.dates import MONTHS\n16 from django.utils.formats import get_format\n17 from django.utils.html import format_html, html_safe\n18 from django.utils.safestring import mark_safe\n19 from django.utils.translation import gettext_lazy as _\n20 \n21 from .renderers import get_default_renderer\n22 \n23 __all__ = (\n24     'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput',\n25     'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput',\n26     'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea',\n27     'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select',\n28     'NullBooleanSelect', 'SelectMultiple', 'RadioSelect',\n29     'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget',\n30     'SplitHiddenDateTimeWidget', 'SelectDateWidget',\n31 )\n32 \n33 MEDIA_TYPES = ('css', 'js')\n34 \n35 \n36 class MediaOrderConflictWarning(RuntimeWarning):\n37     pass\n38 \n39 \n40 @html_safe\n41 class Media:\n42     def __init__(self, media=None, css=None, js=None):\n43         if media is not None:\n44             css = getattr(media, 'css', {})\n45             js = getattr(media, 'js', [])\n46         else:\n47             if css is None:\n48                 css = {}\n49             if js is None:\n50                 js = []\n51         self._css_lists = [css]\n52         self._js_lists = [js]\n53 \n54     def __repr__(self):\n55         return 'Media(css=%r, js=%r)' % (self._css, self._js)\n56 \n57     def __str__(self):\n58         return self.render()\n59 \n60     @property\n61     def _css(self):\n62         css = self._css_lists[0]\n63         # filter(None, ...) avoids calling merge with empty dicts.\n64         for obj in filter(None, self._css_lists[1:]):\n65             css = {\n66                 medium: self.merge(css.get(medium, []), obj.get(medium, []))\n67                 for medium in css.keys() | obj.keys()\n68             }\n69         return css\n70 \n71     @property\n72     def _js(self):\n73         js = self._js_lists[0]\n74         # filter(None, ...) avoids calling merge() with empty lists.\n75         for obj in filter(None, self._js_lists[1:]):\n76             js = self.merge(js, obj)\n77         return js\n78 \n79     def render(self):\n80         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n81 \n82     def render_js(self):\n83         return [\n84             format_html(\n85                 '<script type=\"text/javascript\" src=\"{}\"></script>',\n86                 self.absolute_path(path)\n87             ) for path in self._js\n88         ]\n89 \n90     def render_css(self):\n91         # To keep rendering order consistent, we can't just iterate over items().\n92         # We need to sort the keys, and iterate over the sorted list.\n93         media = sorted(self._css)\n94         return chain.from_iterable([\n95             format_html(\n96                 '<link href=\"{}\" type=\"text/css\" media=\"{}\" rel=\"stylesheet\">',\n97                 self.absolute_path(path), medium\n98             ) for path in self._css[medium]\n99         ] for medium in media)\n100 \n101     def absolute_path(self, path):\n102         \"\"\"\n103         Given a relative or absolute path to a static asset, return an absolute\n104         path. An absolute path will be returned unchanged while a relative path\n105         will be passed to django.templatetags.static.static().\n106         \"\"\"\n107         if path.startswith(('http://', 'https://', '/')):\n108             return path\n109         return static(path)\n110 \n111     def __getitem__(self, name):\n112         \"\"\"Return a Media object that only contains media of the given type.\"\"\"\n113         if name in MEDIA_TYPES:\n114             return Media(**{str(name): getattr(self, '_' + name)})\n115         raise KeyError('Unknown media type \"%s\"' % name)\n116 \n117     @staticmethod\n118     def merge(list_1, list_2):\n119         \"\"\"\n120         Merge two lists while trying to keep the relative order of the elements.\n121         Warn if the lists have the same two elements in a different relative\n122         order.\n123 \n124         For static assets it can be important to have them included in the DOM\n125         in a certain order. In JavaScript you may not be able to reference a\n126         global or in CSS you might want to override a style.\n127         \"\"\"\n128         # Start with a copy of list_1.\n129         combined_list = list(list_1)\n130         last_insert_index = len(list_1)\n131         # Walk list_2 in reverse, inserting each element into combined_list if\n132         # it doesn't already exist.\n133         for path in reversed(list_2):\n134             try:\n135                 # Does path already exist in the list?\n136                 index = combined_list.index(path)\n137             except ValueError:\n138                 # Add path to combined_list since it doesn't exist.\n139                 combined_list.insert(last_insert_index, path)\n140             else:\n141                 if index > last_insert_index:\n142                     warnings.warn(\n143                         'Detected duplicate Media files in an opposite order:\\n'\n144                         '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n145                         MediaOrderConflictWarning,\n146                     )\n147                 # path already exists in the list. Update last_insert_index so\n148                 # that the following elements are inserted in front of this one.\n149                 last_insert_index = index\n150         return combined_list\n151 \n152     def __add__(self, other):\n153         combined = Media()\n154         combined._css_lists = self._css_lists + other._css_lists\n155         combined._js_lists = self._js_lists + other._js_lists\n156         return combined\n157 \n158 \n159 def media_property(cls):\n160     def _media(self):\n161         # Get the media property of the superclass, if it exists\n162         sup_cls = super(cls, self)\n163         try:\n164             base = sup_cls.media\n165         except AttributeError:\n166             base = Media()\n167 \n168         # Get the media definition for this class\n169         definition = getattr(cls, 'Media', None)\n170         if definition:\n171             extend = getattr(definition, 'extend', True)\n172             if extend:\n173                 if extend is True:\n174                     m = base\n175                 else:\n176                     m = Media()\n177                     for medium in extend:\n178                         m = m + base[medium]\n179                 return m + Media(definition)\n180             return Media(definition)\n181         return base\n182     return property(_media)\n183 \n184 \n185 class MediaDefiningClass(type):\n186     \"\"\"\n187     Metaclass for classes that can have media definitions.\n188     \"\"\"\n189     def __new__(mcs, name, bases, attrs):\n190         new_class = super(MediaDefiningClass, mcs).__new__(mcs, name, bases, attrs)\n191 \n192         if 'media' not in attrs:\n193             new_class.media = media_property(new_class)\n194 \n195         return new_class\n196 \n197 \n198 class Widget(metaclass=MediaDefiningClass):\n199     needs_multipart_form = False  # Determines does this widget need multipart form\n200     is_localized = False\n201     is_required = False\n202     supports_microseconds = True\n203 \n204     def __init__(self, attrs=None):\n205         self.attrs = {} if attrs is None else attrs.copy()\n206 \n207     def __deepcopy__(self, memo):\n208         obj = copy.copy(self)\n209         obj.attrs = self.attrs.copy()\n210         memo[id(self)] = obj\n211         return obj\n212 \n213     @property\n214     def is_hidden(self):\n215         return self.input_type == 'hidden' if hasattr(self, 'input_type') else False\n216 \n217     def subwidgets(self, name, value, attrs=None):\n218         context = self.get_context(name, value, attrs)\n219         yield context['widget']\n220 \n221     def format_value(self, value):\n222         \"\"\"\n223         Return a value as it should appear when rendered in a template.\n224         \"\"\"\n225         if value == '' or value is None:\n226             return None\n227         if self.is_localized:\n228             return formats.localize_input(value)\n229         return str(value)\n230 \n231     def get_context(self, name, value, attrs):\n232         context = {}\n233         context['widget'] = {\n234             'name': name,\n235             'is_hidden': self.is_hidden,\n236             'required': self.is_required,\n237             'value': self.format_value(value),\n238             'attrs': self.build_attrs(self.attrs, attrs),\n239             'template_name': self.template_name,\n240         }\n241         return context\n242 \n243     def render(self, name, value, attrs=None, renderer=None):\n244         \"\"\"Render the widget as an HTML string.\"\"\"\n245         context = self.get_context(name, value, attrs)\n246         return self._render(self.template_name, context, renderer)\n247 \n248     def _render(self, template_name, context, renderer=None):\n249         if renderer is None:\n250             renderer = get_default_renderer()\n251         return mark_safe(renderer.render(template_name, context))\n252 \n253     def build_attrs(self, base_attrs, extra_attrs=None):\n254         \"\"\"Build an attribute dictionary.\"\"\"\n255         return {**base_attrs, **(extra_attrs or {})}\n256 \n257     def value_from_datadict(self, data, files, name):\n258         \"\"\"\n259         Given a dictionary of data and this widget's name, return the value\n260         of this widget or None if it's not provided.\n261         \"\"\"\n262         return data.get(name)\n263 \n264     def value_omitted_from_data(self, data, files, name):\n265         return name not in data\n266 \n267     def id_for_label(self, id_):\n268         \"\"\"\n269         Return the HTML ID attribute of this Widget for use by a <label>,\n270         given the ID of the field. Return None if no ID is available.\n271 \n272         This hook is necessary because some widgets have multiple HTML\n273         elements and, thus, multiple IDs. In that case, this method should\n274         return an ID value that corresponds to the first ID in the widget's\n275         tags.\n276         \"\"\"\n277         return id_\n278 \n279     def use_required_attribute(self, initial):\n280         return not self.is_hidden\n281 \n282 \n283 class Input(Widget):\n284     \"\"\"\n285     Base class for all <input> widgets.\n286     \"\"\"\n287     input_type = None  # Subclasses must define this.\n288     template_name = 'django/forms/widgets/input.html'\n289 \n290     def __init__(self, attrs=None):\n291         if attrs is not None:\n292             attrs = attrs.copy()\n293             self.input_type = attrs.pop('type', self.input_type)\n294         super().__init__(attrs)\n295 \n296     def get_context(self, name, value, attrs):\n297         context = super().get_context(name, value, attrs)\n298         context['widget']['type'] = self.input_type\n299         return context\n300 \n301 \n302 class TextInput(Input):\n303     input_type = 'text'\n304     template_name = 'django/forms/widgets/text.html'\n305 \n306 \n307 class NumberInput(Input):\n308     input_type = 'number'\n309     template_name = 'django/forms/widgets/number.html'\n310 \n311 \n312 class EmailInput(Input):\n313     input_type = 'email'\n314     template_name = 'django/forms/widgets/email.html'\n315 \n316 \n317 class URLInput(Input):\n318     input_type = 'url'\n319     template_name = 'django/forms/widgets/url.html'\n320 \n321 \n322 class PasswordInput(Input):\n323     input_type = 'password'\n324     template_name = 'django/forms/widgets/password.html'\n325 \n326     def __init__(self, attrs=None, render_value=False):\n327         super().__init__(attrs)\n328         self.render_value = render_value\n329 \n330     def get_context(self, name, value, attrs):\n331         if not self.render_value:\n332             value = None\n333         return super().get_context(name, value, attrs)\n334 \n335 \n336 class HiddenInput(Input):\n337     input_type = 'hidden'\n338     template_name = 'django/forms/widgets/hidden.html'\n339 \n340 \n341 class MultipleHiddenInput(HiddenInput):\n342     \"\"\"\n343     Handle <input type=\"hidden\"> for fields that have a list\n344     of values.\n345     \"\"\"\n346     template_name = 'django/forms/widgets/multiple_hidden.html'\n347 \n348     def get_context(self, name, value, attrs):\n349         context = super().get_context(name, value, attrs)\n350         final_attrs = context['widget']['attrs']\n351         id_ = context['widget']['attrs'].get('id')\n352 \n353         subwidgets = []\n354         for index, value_ in enumerate(context['widget']['value']):\n355             widget_attrs = final_attrs.copy()\n356             if id_:\n357                 # An ID attribute was given. Add a numeric index as a suffix\n358                 # so that the inputs don't all have the same ID attribute.\n359                 widget_attrs['id'] = '%s_%s' % (id_, index)\n360             widget = HiddenInput()\n361             widget.is_required = self.is_required\n362             subwidgets.append(widget.get_context(name, value_, widget_attrs)['widget'])\n363 \n364         context['widget']['subwidgets'] = subwidgets\n365         return context\n366 \n367     def value_from_datadict(self, data, files, name):\n368         try:\n369             getter = data.getlist\n370         except AttributeError:\n371             getter = data.get\n372         return getter(name)\n373 \n374     def format_value(self, value):\n375         return [] if value is None else value\n376 \n377 \n378 class FileInput(Input):\n379     input_type = 'file'\n380     needs_multipart_form = True\n381     template_name = 'django/forms/widgets/file.html'\n382 \n383     def format_value(self, value):\n384         \"\"\"File input never renders a value.\"\"\"\n385         return\n386 \n387     def value_from_datadict(self, data, files, name):\n388         \"File widgets take data from FILES, not POST\"\n389         return files.get(name)\n390 \n391     def value_omitted_from_data(self, data, files, name):\n392         return name not in files\n393 \n394 \n395 FILE_INPUT_CONTRADICTION = object()\n396 \n397 \n398 class ClearableFileInput(FileInput):\n399     clear_checkbox_label = _('Clear')\n400     initial_text = _('Currently')\n401     input_text = _('Change')\n402     template_name = 'django/forms/widgets/clearable_file_input.html'\n403 \n404     def clear_checkbox_name(self, name):\n405         \"\"\"\n406         Given the name of the file input, return the name of the clear checkbox\n407         input.\n408         \"\"\"\n409         return name + '-clear'\n410 \n411     def clear_checkbox_id(self, name):\n412         \"\"\"\n413         Given the name of the clear checkbox input, return the HTML id for it.\n414         \"\"\"\n415         return name + '_id'\n416 \n417     def is_initial(self, value):\n418         \"\"\"\n419         Return whether value is considered to be initial value.\n420         \"\"\"\n421         return bool(value and getattr(value, 'url', False))\n422 \n423     def format_value(self, value):\n424         \"\"\"\n425         Return the file object if it has a defined url attribute.\n426         \"\"\"\n427         if self.is_initial(value):\n428             return value\n429 \n430     def get_context(self, name, value, attrs):\n431         context = super().get_context(name, value, attrs)\n432         checkbox_name = self.clear_checkbox_name(name)\n433         checkbox_id = self.clear_checkbox_id(checkbox_name)\n434         context['widget'].update({\n435             'checkbox_name': checkbox_name,\n436             'checkbox_id': checkbox_id,\n437             'is_initial': self.is_initial(value),\n438             'input_text': self.input_text,\n439             'initial_text': self.initial_text,\n440             'clear_checkbox_label': self.clear_checkbox_label,\n441         })\n442         return context\n443 \n444     def value_from_datadict(self, data, files, name):\n445         upload = super().value_from_datadict(data, files, name)\n446         if not self.is_required and CheckboxInput().value_from_datadict(\n447                 data, files, self.clear_checkbox_name(name)):\n448 \n449             if upload:\n450                 # If the user contradicts themselves (uploads a new file AND\n451                 # checks the \"clear\" checkbox), we return a unique marker\n452                 # object that FileField will turn into a ValidationError.\n453                 return FILE_INPUT_CONTRADICTION\n454             # False signals to clear any existing value, as opposed to just None\n455             return False\n456         return upload\n457 \n458     def use_required_attribute(self, initial):\n459         return super().use_required_attribute(initial) and not initial\n460 \n461     def value_omitted_from_data(self, data, files, name):\n462         return (\n463             super().value_omitted_from_data(data, files, name) and\n464             self.clear_checkbox_name(name) not in data\n465         )\n466 \n467 \n468 class Textarea(Widget):\n469     template_name = 'django/forms/widgets/textarea.html'\n470 \n471     def __init__(self, attrs=None):\n472         # Use slightly better defaults than HTML's 20x2 box\n473         default_attrs = {'cols': '40', 'rows': '10'}\n474         if attrs:\n475             default_attrs.update(attrs)\n476         super().__init__(default_attrs)\n477 \n478 \n479 class DateTimeBaseInput(TextInput):\n480     format_key = ''\n481     supports_microseconds = False\n482 \n483     def __init__(self, attrs=None, format=None):\n484         super().__init__(attrs)\n485         self.format = format or None\n486 \n487     def format_value(self, value):\n488         return formats.localize_input(value, self.format or formats.get_format(self.format_key)[0])\n489 \n490 \n491 class DateInput(DateTimeBaseInput):\n492     format_key = 'DATE_INPUT_FORMATS'\n493     template_name = 'django/forms/widgets/date.html'\n494 \n495 \n496 class DateTimeInput(DateTimeBaseInput):\n497     format_key = 'DATETIME_INPUT_FORMATS'\n498     template_name = 'django/forms/widgets/datetime.html'\n499 \n500 \n501 class TimeInput(DateTimeBaseInput):\n502     format_key = 'TIME_INPUT_FORMATS'\n503     template_name = 'django/forms/widgets/time.html'\n504 \n505 \n506 # Defined at module level so that CheckboxInput is picklable (#17976)\n507 def boolean_check(v):\n508     return not (v is False or v is None or v == '')\n509 \n510 \n511 class CheckboxInput(Input):\n512     input_type = 'checkbox'\n513     template_name = 'django/forms/widgets/checkbox.html'\n514 \n515     def __init__(self, attrs=None, check_test=None):\n516         super().__init__(attrs)\n517         # check_test is a callable that takes a value and returns True\n518         # if the checkbox should be checked for that value.\n519         self.check_test = boolean_check if check_test is None else check_test\n520 \n521     def format_value(self, value):\n522         \"\"\"Only return the 'value' attribute if value isn't empty.\"\"\"\n523         if value is True or value is False or value is None or value == '':\n524             return\n525         return str(value)\n526 \n527     def get_context(self, name, value, attrs):\n528         if self.check_test(value):\n529             if attrs is None:\n530                 attrs = {}\n531             attrs['checked'] = True\n532         return super().get_context(name, value, attrs)\n533 \n534     def value_from_datadict(self, data, files, name):\n535         if name not in data:\n536             # A missing value means False because HTML form submission does not\n537             # send results for unselected checkboxes.\n538             return False\n539         value = data.get(name)\n540         # Translate true and false strings to boolean values.\n541         values = {'true': True, 'false': False}\n542         if isinstance(value, str):\n543             value = values.get(value.lower(), value)\n544         return bool(value)\n545 \n546     def value_omitted_from_data(self, data, files, name):\n547         # HTML checkboxes don't appear in POST data if not checked, so it's\n548         # never known if the value is actually omitted.\n549         return False\n550 \n551 \n552 class ChoiceWidget(Widget):\n553     allow_multiple_selected = False\n554     input_type = None\n555     template_name = None\n556     option_template_name = None\n557     add_id_index = True\n558     checked_attribute = {'checked': True}\n559     option_inherits_attrs = True\n560 \n561     def __init__(self, attrs=None, choices=()):\n562         super().__init__(attrs)\n563         # choices can be any iterable, but we may need to render this widget\n564         # multiple times. Thus, collapse it into a list so it can be consumed\n565         # more than once.\n566         self.choices = list(choices)\n567 \n568     def __deepcopy__(self, memo):\n569         obj = copy.copy(self)\n570         obj.attrs = self.attrs.copy()\n571         obj.choices = copy.copy(self.choices)\n572         memo[id(self)] = obj\n573         return obj\n574 \n575     def subwidgets(self, name, value, attrs=None):\n576         \"\"\"\n577         Yield all \"subwidgets\" of this widget. Used to enable iterating\n578         options from a BoundField for choice widgets.\n579         \"\"\"\n580         value = self.format_value(value)\n581         yield from self.options(name, value, attrs)\n582 \n583     def options(self, name, value, attrs=None):\n584         \"\"\"Yield a flat list of options for this widgets.\"\"\"\n585         for group in self.optgroups(name, value, attrs):\n586             yield from group[1]\n587 \n588     def optgroups(self, name, value, attrs=None):\n589         \"\"\"Return a list of optgroups for this widget.\"\"\"\n590         groups = []\n591         has_selected = False\n592 \n593         for index, (option_value, option_label) in enumerate(self.choices):\n594             if option_value is None:\n595                 option_value = ''\n596 \n597             subgroup = []\n598             if isinstance(option_label, (list, tuple)):\n599                 group_name = option_value\n600                 subindex = 0\n601                 choices = option_label\n602             else:\n603                 group_name = None\n604                 subindex = None\n605                 choices = [(option_value, option_label)]\n606             groups.append((group_name, subgroup, index))\n607 \n608             for subvalue, sublabel in choices:\n609                 selected = (\n610                     str(subvalue) in value and\n611                     (not has_selected or self.allow_multiple_selected)\n612                 )\n613                 has_selected |= selected\n614                 subgroup.append(self.create_option(\n615                     name, subvalue, sublabel, selected, index,\n616                     subindex=subindex, attrs=attrs,\n617                 ))\n618                 if subindex is not None:\n619                     subindex += 1\n620         return groups\n621 \n622     def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):\n623         index = str(index) if subindex is None else \"%s_%s\" % (index, subindex)\n624         if attrs is None:\n625             attrs = {}\n626         option_attrs = self.build_attrs(self.attrs, attrs) if self.option_inherits_attrs else {}\n627         if selected:\n628             option_attrs.update(self.checked_attribute)\n629         if 'id' in option_attrs:\n630             option_attrs['id'] = self.id_for_label(option_attrs['id'], index)\n631         return {\n632             'name': name,\n633             'value': value,\n634             'label': label,\n635             'selected': selected,\n636             'index': index,\n637             'attrs': option_attrs,\n638             'type': self.input_type,\n639             'template_name': self.option_template_name,\n640             'wrap_label': True,\n641         }\n642 \n643     def get_context(self, name, value, attrs):\n644         context = super().get_context(name, value, attrs)\n645         context['widget']['optgroups'] = self.optgroups(name, context['widget']['value'], attrs)\n646         return context\n647 \n648     def id_for_label(self, id_, index='0'):\n649         \"\"\"\n650         Use an incremented id for each option where the main widget\n651         references the zero index.\n652         \"\"\"\n653         if id_ and self.add_id_index:\n654             id_ = '%s_%s' % (id_, index)\n655         return id_\n656 \n657     def value_from_datadict(self, data, files, name):\n658         getter = data.get\n659         if self.allow_multiple_selected:\n660             try:\n661                 getter = data.getlist\n662             except AttributeError:\n663                 pass\n664         return getter(name)\n665 \n666     def format_value(self, value):\n667         \"\"\"Return selected values as a list.\"\"\"\n668         if value is None and self.allow_multiple_selected:\n669             return []\n670         if not isinstance(value, (tuple, list)):\n671             value = [value]\n672         return [str(v) if v is not None else '' for v in value]\n673 \n674 \n675 class Select(ChoiceWidget):\n676     input_type = 'select'\n677     template_name = 'django/forms/widgets/select.html'\n678     option_template_name = 'django/forms/widgets/select_option.html'\n679     add_id_index = False\n680     checked_attribute = {'selected': True}\n681     option_inherits_attrs = False\n682 \n683     def get_context(self, name, value, attrs):\n684         context = super().get_context(name, value, attrs)\n685         if self.allow_multiple_selected:\n686             context['widget']['attrs']['multiple'] = True\n687         return context\n688 \n689     @staticmethod\n690     def _choice_has_empty_value(choice):\n691         \"\"\"Return True if the choice's value is empty string or None.\"\"\"\n692         value, _ = choice\n693         return value is None or value == ''\n694 \n695     def use_required_attribute(self, initial):\n696         \"\"\"\n697         Don't render 'required' if the first <option> has a value, as that's\n698         invalid HTML.\n699         \"\"\"\n700         use_required_attribute = super().use_required_attribute(initial)\n701         # 'required' is always okay for <select multiple>.\n702         if self.allow_multiple_selected:\n703             return use_required_attribute\n704 \n705         first_choice = next(iter(self.choices), None)\n706         return use_required_attribute and first_choice is not None and self._choice_has_empty_value(first_choice)\n707 \n708 \n709 class NullBooleanSelect(Select):\n710     \"\"\"\n711     A Select Widget intended to be used with NullBooleanField.\n712     \"\"\"\n713     def __init__(self, attrs=None):\n714         choices = (\n715             ('unknown', _('Unknown')),\n716             ('true', _('Yes')),\n717             ('false', _('No')),\n718         )\n719         super().__init__(attrs, choices)\n720 \n721     def format_value(self, value):\n722         try:\n723             return {\n724                 True: 'true', False: 'false',\n725                 'true': 'true', 'false': 'false',\n726                 # For backwards compatibility with Django < 2.2.\n727                 '2': 'true', '3': 'false',\n728             }[value]\n729         except KeyError:\n730             return 'unknown'\n731 \n732     def value_from_datadict(self, data, files, name):\n733         value = data.get(name)\n734         return {\n735             True: True,\n736             'True': True,\n737             'False': False,\n738             False: False,\n739             'true': True,\n740             'false': False,\n741             # For backwards compatibility with Django < 2.2.\n742             '2': True,\n743             '3': False,\n744         }.get(value)\n745 \n746 \n747 class SelectMultiple(Select):\n748     allow_multiple_selected = True\n749 \n750     def value_from_datadict(self, data, files, name):\n751         try:\n752             getter = data.getlist\n753         except AttributeError:\n754             getter = data.get\n755         return getter(name)\n756 \n757     def value_omitted_from_data(self, data, files, name):\n758         # An unselected <select multiple> doesn't appear in POST data, so it's\n759         # never known if the value is actually omitted.\n760         return False\n761 \n762 \n763 class RadioSelect(ChoiceWidget):\n764     input_type = 'radio'\n765     template_name = 'django/forms/widgets/radio.html'\n766     option_template_name = 'django/forms/widgets/radio_option.html'\n767 \n768 \n769 class CheckboxSelectMultiple(ChoiceWidget):\n770     allow_multiple_selected = True\n771     input_type = 'checkbox'\n772     template_name = 'django/forms/widgets/checkbox_select.html'\n773     option_template_name = 'django/forms/widgets/checkbox_option.html'\n774 \n775     def use_required_attribute(self, initial):\n776         # Don't use the 'required' attribute because browser validation would\n777         # require all checkboxes to be checked instead of at least one.\n778         return False\n779 \n780     def value_omitted_from_data(self, data, files, name):\n781         # HTML checkboxes don't appear in POST data if not checked, so it's\n782         # never known if the value is actually omitted.\n783         return False\n784 \n785     def id_for_label(self, id_, index=None):\n786         \"\"\"\"\n787         Don't include for=\"field_0\" in <label> because clicking such a label\n788         would toggle the first checkbox.\n789         \"\"\"\n790         if index is None:\n791             return ''\n792         return super().id_for_label(id_, index)\n793 \n794 \n795 class MultiWidget(Widget):\n796     \"\"\"\n797     A widget that is composed of multiple widgets.\n798 \n799     In addition to the values added by Widget.get_context(), this widget\n800     adds a list of subwidgets to the context as widget['subwidgets'].\n801     These can be looped over and rendered like normal widgets.\n802 \n803     You'll probably want to use this class with MultiValueField.\n804     \"\"\"\n805     template_name = 'django/forms/widgets/multiwidget.html'\n806 \n807     def __init__(self, widgets, attrs=None):\n808         self.widgets = [w() if isinstance(w, type) else w for w in widgets]\n809         super().__init__(attrs)\n810 \n811     @property\n812     def is_hidden(self):\n813         return all(w.is_hidden for w in self.widgets)\n814 \n815     def get_context(self, name, value, attrs):\n816         context = super().get_context(name, value, attrs)\n817         if self.is_localized:\n818             for widget in self.widgets:\n819                 widget.is_localized = self.is_localized\n820         # value is a list of values, each corresponding to a widget\n821         # in self.widgets.\n822         if not isinstance(value, list):\n823             value = self.decompress(value)\n824 \n825         final_attrs = context['widget']['attrs']\n826         input_type = final_attrs.pop('type', None)\n827         id_ = final_attrs.get('id')\n828         subwidgets = []\n829         for i, widget in enumerate(self.widgets):\n830             if input_type is not None:\n831                 widget.input_type = input_type\n832             widget_name = '%s_%s' % (name, i)\n833             try:\n834                 widget_value = value[i]\n835             except IndexError:\n836                 widget_value = None\n837             if id_:\n838                 widget_attrs = final_attrs.copy()\n839                 widget_attrs['id'] = '%s_%s' % (id_, i)\n840             else:\n841                 widget_attrs = final_attrs\n842             subwidgets.append(widget.get_context(widget_name, widget_value, widget_attrs)['widget'])\n843         context['widget']['subwidgets'] = subwidgets\n844         return context\n845 \n846     def id_for_label(self, id_):\n847         if id_:\n848             id_ += '_0'\n849         return id_\n850 \n851     def value_from_datadict(self, data, files, name):\n852         return [widget.value_from_datadict(data, files, name + '_%s' % i) for i, widget in enumerate(self.widgets)]\n853 \n854     def value_omitted_from_data(self, data, files, name):\n855         return all(\n856             widget.value_omitted_from_data(data, files, name + '_%s' % i)\n857             for i, widget in enumerate(self.widgets)\n858         )\n859 \n860     def decompress(self, value):\n861         \"\"\"\n862         Return a list of decompressed values for the given compressed value.\n863         The given value can be assumed to be valid, but not necessarily\n864         non-empty.\n865         \"\"\"\n866         raise NotImplementedError('Subclasses must implement this method.')\n867 \n868     def _get_media(self):\n869         \"\"\"\n870         Media for a multiwidget is the combination of all media of the\n871         subwidgets.\n872         \"\"\"\n873         media = Media()\n874         for w in self.widgets:\n875             media = media + w.media\n876         return media\n877     media = property(_get_media)\n878 \n879     def __deepcopy__(self, memo):\n880         obj = super().__deepcopy__(memo)\n881         obj.widgets = copy.deepcopy(self.widgets)\n882         return obj\n883 \n884     @property\n885     def needs_multipart_form(self):\n886         return any(w.needs_multipart_form for w in self.widgets)\n887 \n888 \n889 class SplitDateTimeWidget(MultiWidget):\n890     \"\"\"\n891     A widget that splits datetime input into two <input type=\"text\"> boxes.\n892     \"\"\"\n893     supports_microseconds = False\n894     template_name = 'django/forms/widgets/splitdatetime.html'\n895 \n896     def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):\n897         widgets = (\n898             DateInput(\n899                 attrs=attrs if date_attrs is None else date_attrs,\n900                 format=date_format,\n901             ),\n902             TimeInput(\n903                 attrs=attrs if time_attrs is None else time_attrs,\n904                 format=time_format,\n905             ),\n906         )\n907         super().__init__(widgets)\n908 \n909     def decompress(self, value):\n910         if value:\n911             value = to_current_timezone(value)\n912             return [value.date(), value.time()]\n913         return [None, None]\n914 \n915 \n916 class SplitHiddenDateTimeWidget(SplitDateTimeWidget):\n917     \"\"\"\n918     A widget that splits datetime input into two <input type=\"hidden\"> inputs.\n919     \"\"\"\n920     template_name = 'django/forms/widgets/splithiddendatetime.html'\n921 \n922     def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):\n923         super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)\n924         for widget in self.widgets:\n925             widget.input_type = 'hidden'\n926 \n927 \n928 class SelectDateWidget(Widget):\n929     \"\"\"\n930     A widget that splits date input into three <select> boxes.\n931 \n932     This also serves as an example of a Widget that has more than one HTML\n933     element and hence implements value_from_datadict.\n934     \"\"\"\n935     none_value = ('', '---')\n936     month_field = '%s_month'\n937     day_field = '%s_day'\n938     year_field = '%s_year'\n939     template_name = 'django/forms/widgets/select_date.html'\n940     input_type = 'select'\n941     select_widget = Select\n942     date_re = re.compile(r'(\\d{4}|0)-(\\d\\d?)-(\\d\\d?)$')\n943 \n944     def __init__(self, attrs=None, years=None, months=None, empty_label=None):\n945         self.attrs = attrs or {}\n946 \n947         # Optional list or tuple of years to use in the \"year\" select box.\n948         if years:\n949             self.years = years\n950         else:\n951             this_year = datetime.date.today().year\n952             self.years = range(this_year, this_year + 10)\n953 \n954         # Optional dict of months to use in the \"month\" select box.\n955         if months:\n956             self.months = months\n957         else:\n958             self.months = MONTHS\n959 \n960         # Optional string, list, or tuple to use as empty_label.\n961         if isinstance(empty_label, (list, tuple)):\n962             if not len(empty_label) == 3:\n963                 raise ValueError('empty_label list/tuple must have 3 elements.')\n964 \n965             self.year_none_value = ('', empty_label[0])\n966             self.month_none_value = ('', empty_label[1])\n967             self.day_none_value = ('', empty_label[2])\n968         else:\n969             if empty_label is not None:\n970                 self.none_value = ('', empty_label)\n971 \n972             self.year_none_value = self.none_value\n973             self.month_none_value = self.none_value\n974             self.day_none_value = self.none_value\n975 \n976     def get_context(self, name, value, attrs):\n977         context = super().get_context(name, value, attrs)\n978         date_context = {}\n979         year_choices = [(i, str(i)) for i in self.years]\n980         if not self.is_required:\n981             year_choices.insert(0, self.year_none_value)\n982         year_name = self.year_field % name\n983         date_context['year'] = self.select_widget(attrs, choices=year_choices).get_context(\n984             name=year_name,\n985             value=context['widget']['value']['year'],\n986             attrs={**context['widget']['attrs'], 'id': 'id_%s' % year_name},\n987         )\n988         month_choices = list(self.months.items())\n989         if not self.is_required:\n990             month_choices.insert(0, self.month_none_value)\n991         month_name = self.month_field % name\n992         date_context['month'] = self.select_widget(attrs, choices=month_choices).get_context(\n993             name=month_name,\n994             value=context['widget']['value']['month'],\n995             attrs={**context['widget']['attrs'], 'id': 'id_%s' % month_name},\n996         )\n997         day_choices = [(i, i) for i in range(1, 32)]\n998         if not self.is_required:\n999             day_choices.insert(0, self.day_none_value)\n1000         day_name = self.day_field % name\n1001         date_context['day'] = self.select_widget(attrs, choices=day_choices,).get_context(\n1002             name=day_name,\n1003             value=context['widget']['value']['day'],\n1004             attrs={**context['widget']['attrs'], 'id': 'id_%s' % day_name},\n1005         )\n1006         subwidgets = []\n1007         for field in self._parse_date_fmt():\n1008             subwidgets.append(date_context[field]['widget'])\n1009         context['widget']['subwidgets'] = subwidgets\n1010         return context\n1011 \n1012     def format_value(self, value):\n1013         \"\"\"\n1014         Return a dict containing the year, month, and day of the current value.\n1015         Use dict instead of a datetime to allow invalid dates such as February\n1016         31 to display correctly.\n1017         \"\"\"\n1018         year, month, day = None, None, None\n1019         if isinstance(value, (datetime.date, datetime.datetime)):\n1020             year, month, day = value.year, value.month, value.day\n1021         elif isinstance(value, str):\n1022             match = self.date_re.match(value)\n1023             if match:\n1024                 # Convert any zeros in the date to empty strings to match the\n1025                 # empty option value.\n1026                 year, month, day = [int(val) or '' for val in match.groups()]\n1027             elif settings.USE_L10N:\n1028                 input_format = get_format('DATE_INPUT_FORMATS')[0]\n1029                 try:\n1030                     d = datetime.datetime.strptime(value, input_format)\n1031                 except ValueError:\n1032                     pass\n1033                 else:\n1034                     year, month, day = d.year, d.month, d.day\n1035         return {'year': year, 'month': month, 'day': day}\n1036 \n1037     @staticmethod\n1038     def _parse_date_fmt():\n1039         fmt = get_format('DATE_FORMAT')\n1040         escaped = False\n1041         for char in fmt:\n1042             if escaped:\n1043                 escaped = False\n1044             elif char == '\\\\':\n1045                 escaped = True\n1046             elif char in 'Yy':\n1047                 yield 'year'\n1048             elif char in 'bEFMmNn':\n1049                 yield 'month'\n1050             elif char in 'dj':\n1051                 yield 'day'\n1052 \n1053     def id_for_label(self, id_):\n1054         for first_select in self._parse_date_fmt():\n1055             return '%s_%s' % (id_, first_select)\n1056         return '%s_month' % id_\n1057 \n1058     def value_from_datadict(self, data, files, name):\n1059         y = data.get(self.year_field % name)\n1060         m = data.get(self.month_field % name)\n1061         d = data.get(self.day_field % name)\n1062         if y == m == d == '':\n1063             return None\n1064         if y is not None and m is not None and d is not None:\n1065             if settings.USE_L10N:\n1066                 input_format = get_format('DATE_INPUT_FORMATS')[0]\n1067                 try:\n1068                     date_value = datetime.date(int(y), int(m), int(d))\n1069                 except ValueError:\n1070                     pass\n1071                 else:\n1072                     date_value = datetime_safe.new_date(date_value)\n1073                     return date_value.strftime(input_format)\n1074             # Return pseudo-ISO dates with zeros for any unselected values,\n1075             # e.g. '2017-0-23'.\n1076             return '%s-%s-%s' % (y or 0, m or 0, d or 0)\n1077         return data.get(name)\n1078 \n1079     def value_omitted_from_data(self, data, files, name):\n1080         return not any(\n1081             ('{}_{}'.format(name, interval) in data)\n1082             for interval in ('year', 'month', 'day')\n1083         )\n1084 \n[end of django/forms/widgets.py]\n</code>\nI need you to solve this issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the following format.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\n"
}
{
  "instance_id": "django__django-10924",
  "variant": "oracle",
  "split": "test",
  "meta": {
    "instance_id": "django__django-10924",
    "repo": "django/django",
    "base_commit": "bceadd2788dc2dad53eba0caae172bd8522fd483",
    "patch": "<patch>\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -1709,7 +1709,7 @@ def get_prep_value(self, value):\n \n     def formfield(self, **kwargs):\n         return super().formfield(**{\n-            'path': self.path,\n+            'path': self.path() if callable(self.path) else self.path,\n             'match': self.match,\n             'recursive': self.recursive,\n             'form_class': forms.FilePathField,\n\n</patch>",
    "test_patch": "diff --git a/tests/model_fields/test_filepathfield.py b/tests/model_fields/test_filepathfield.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/model_fields/test_filepathfield.py\n@@ -0,0 +1,22 @@\n+import os\n+\n+from django.db.models import FilePathField\n+from django.test import SimpleTestCase\n+\n+\n+class FilePathFieldTests(SimpleTestCase):\n+    def test_path(self):\n+        path = os.path.dirname(__file__)\n+        field = FilePathField(path=path)\n+        self.assertEqual(field.path, path)\n+        self.assertEqual(field.formfield().path, path)\n+\n+    def test_callable_path(self):\n+        path = os.path.dirname(__file__)\n+\n+        def generate_path():\n+            return path\n+\n+        field = FilePathField(path=generate_path)\n+        self.assertEqual(field.path(), path)\n+        self.assertEqual(field.formfield().path, path)\n",
    "created_at": "2019-02-03T11:30:12Z",
    "version": "3.0",
    "FAIL_TO_PASS": "[\"test_callable_path (model_fields.test_filepathfield.FilePathFieldTests)\"]",
    "PASS_TO_PASS": "[\"test_path (model_fields.test_filepathfield.FilePathFieldTests)\"]"
  },
  "text": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nAllow FilePathField path to accept a callable.\nDescription\n\t\nI have a special case where I want to create a model containing the path to some local files on the server/dev machine. Seeing as the place where these files are stored is different on different machines I have the following:\nimport os\nfrom django.conf import settings\nfrom django.db import models\nclass LocalFiles(models.Model):\n\tname = models.CharField(max_length=255)\n\tfile = models.FilePathField(path=os.path.join(settings.LOCAL_FILE_DIR, 'example_dir'))\nNow when running manage.py makemigrations it will resolve the path based on the machine it is being run on. Eg: /home/<username>/server_files/example_dir\nI had to manually change the migration to include the os.path.join() part to not break this when running the migration on production/other machine.\n\n</issue>\n<code>\n[start of README.rst]\n1 Django is a high-level Python Web framework that encourages rapid development\n2 and clean, pragmatic design. Thanks for checking it out.\n3 \n4 All documentation is in the \"``docs``\" directory and online at\n5 https://docs.djangoproject.com/en/stable/. If you're just getting started,\n6 here's how we recommend you read the docs:\n7 \n8 * First, read ``docs/intro/install.txt`` for instructions on installing Django.\n9 \n10 * Next, work through the tutorials in order (``docs/intro/tutorial01.txt``,\n11   ``docs/intro/tutorial02.txt``, etc.).\n12 \n13 * If you want to set up an actual deployment server, read\n14   ``docs/howto/deployment/index.txt`` for instructions.\n15 \n16 * You'll probably want to read through the topical guides (in ``docs/topics``)\n17   next; from there you can jump to the HOWTOs (in ``docs/howto``) for specific\n18   problems, and check out the reference (``docs/ref``) for gory details.\n19 \n20 * See ``docs/README`` for instructions on building an HTML version of the docs.\n21 \n22 Docs are updated rigorously. If you find any problems in the docs, or think\n23 they should be clarified in any way, please take 30 seconds to fill out a\n24 ticket here: https://code.djangoproject.com/newticket\n25 \n26 To get more help:\n27 \n28 * Join the ``#django`` channel on irc.freenode.net. Lots of helpful people hang\n29   out there. See https://en.wikipedia.org/wiki/Wikipedia:IRC/Tutorial if you're\n30   new to IRC.\n31 \n32 * Join the django-users mailing list, or read the archives, at\n33   https://groups.google.com/group/django-users.\n34 \n35 To contribute to Django:\n36 \n37 * Check out https://docs.djangoproject.com/en/dev/internals/contributing/ for\n38   information about getting involved.\n39 \n40 To run Django's test suite:\n41 \n42 * Follow the instructions in the \"Unit tests\" section of\n43   ``docs/internals/contributing/writing-code/unit-tests.txt``, published online at\n44   https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/unit-tests/#running-the-unit-tests\n45 \n[end of README.rst]\n[start of django/db/models/fields/__init__.py]\n1 import collections.abc\n2 import copy\n3 import datetime\n4 import decimal\n5 import operator\n6 import uuid\n7 import warnings\n8 from base64 import b64decode, b64encode\n9 from functools import partialmethod, total_ordering\n10 \n11 from django import forms\n12 from django.apps import apps\n13 from django.conf import settings\n14 from django.core import checks, exceptions, validators\n15 # When the _meta object was formalized, this exception was moved to\n16 # django.core.exceptions. It is retained here for backwards compatibility\n17 # purposes.\n18 from django.core.exceptions import FieldDoesNotExist  # NOQA\n19 from django.db import connection, connections, router\n20 from django.db.models.constants import LOOKUP_SEP\n21 from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n22 from django.utils import timezone\n23 from django.utils.datastructures import DictWrapper\n24 from django.utils.dateparse import (\n25     parse_date, parse_datetime, parse_duration, parse_time,\n26 )\n27 from django.utils.duration import duration_microseconds, duration_string\n28 from django.utils.functional import Promise, cached_property\n29 from django.utils.ipv6 import clean_ipv6_address\n30 from django.utils.itercompat import is_iterable\n31 from django.utils.text import capfirst\n32 from django.utils.translation import gettext_lazy as _\n33 \n34 __all__ = [\n35     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',\n36     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',\n37     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',\n38     'EmailField', 'Empty', 'Field', 'FieldDoesNotExist', 'FilePathField',\n39     'FloatField', 'GenericIPAddressField', 'IPAddressField', 'IntegerField',\n40     'NOT_PROVIDED', 'NullBooleanField', 'PositiveIntegerField',\n41     'PositiveSmallIntegerField', 'SlugField', 'SmallIntegerField', 'TextField',\n42     'TimeField', 'URLField', 'UUIDField',\n43 ]\n44 \n45 \n46 class Empty:\n47     pass\n48 \n49 \n50 class NOT_PROVIDED:\n51     pass\n52 \n53 \n54 # The values to use for \"blank\" in SelectFields. Will be appended to the start\n55 # of most \"choices\" lists.\n56 BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n57 \n58 \n59 def _load_field(app_label, model_name, field_name):\n60     return apps.get_model(app_label, model_name)._meta.get_field(field_name)\n61 \n62 \n63 # A guide to Field parameters:\n64 #\n65 #   * name:      The name of the field specified in the model.\n66 #   * attname:   The attribute to use on the model object. This is the same as\n67 #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n68 #                appended.\n69 #   * db_column: The db_column specified in the model (or None).\n70 #   * column:    The database column for this field. This is the same as\n71 #                \"attname\", except if db_column is specified.\n72 #\n73 # Code that introspects values, or does other dynamic things, should use\n74 # attname. For example, this gets the primary key value of object \"obj\":\n75 #\n76 #     getattr(obj, opts.pk.attname)\n77 \n78 def _empty(of_cls):\n79     new = Empty()\n80     new.__class__ = of_cls\n81     return new\n82 \n83 \n84 def return_None():\n85     return None\n86 \n87 \n88 @total_ordering\n89 class Field(RegisterLookupMixin):\n90     \"\"\"Base class for all field types\"\"\"\n91 \n92     # Designates whether empty strings fundamentally are allowed at the\n93     # database level.\n94     empty_strings_allowed = True\n95     empty_values = list(validators.EMPTY_VALUES)\n96 \n97     # These track each time a Field instance is created. Used to retain order.\n98     # The auto_creation_counter is used for fields that Django implicitly\n99     # creates, creation_counter is used for all user-specified fields.\n100     creation_counter = 0\n101     auto_creation_counter = -1\n102     default_validators = []  # Default set of validators\n103     default_error_messages = {\n104         'invalid_choice': _('Value %(value)r is not a valid choice.'),\n105         'null': _('This field cannot be null.'),\n106         'blank': _('This field cannot be blank.'),\n107         'unique': _('%(model_name)s with this %(field_label)s '\n108                     'already exists.'),\n109         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n110         # Eg: \"Title must be unique for pub_date year\"\n111         'unique_for_date': _(\"%(field_label)s must be unique for \"\n112                              \"%(date_field_label)s %(lookup_type)s.\"),\n113     }\n114     system_check_deprecated_details = None\n115     system_check_removed_details = None\n116 \n117     # Field flags\n118     hidden = False\n119 \n120     many_to_many = None\n121     many_to_one = None\n122     one_to_many = None\n123     one_to_one = None\n124     related_model = None\n125 \n126     # Generic field type description, usually overridden by subclasses\n127     def _description(self):\n128         return _('Field of type: %(field_type)s') % {\n129             'field_type': self.__class__.__name__\n130         }\n131     description = property(_description)\n132 \n133     def __init__(self, verbose_name=None, name=None, primary_key=False,\n134                  max_length=None, unique=False, blank=False, null=False,\n135                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n136                  serialize=True, unique_for_date=None, unique_for_month=None,\n137                  unique_for_year=None, choices=None, help_text='', db_column=None,\n138                  db_tablespace=None, auto_created=False, validators=(),\n139                  error_messages=None):\n140         self.name = name\n141         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n142         self._verbose_name = verbose_name  # Store original for deconstruction\n143         self.primary_key = primary_key\n144         self.max_length, self._unique = max_length, unique\n145         self.blank, self.null = blank, null\n146         self.remote_field = rel\n147         self.is_relation = self.remote_field is not None\n148         self.default = default\n149         self.editable = editable\n150         self.serialize = serialize\n151         self.unique_for_date = unique_for_date\n152         self.unique_for_month = unique_for_month\n153         self.unique_for_year = unique_for_year\n154         if isinstance(choices, collections.abc.Iterator):\n155             choices = list(choices)\n156         self.choices = choices\n157         self.help_text = help_text\n158         self.db_index = db_index\n159         self.db_column = db_column\n160         self._db_tablespace = db_tablespace\n161         self.auto_created = auto_created\n162 \n163         # Adjust the appropriate creation counter, and save our local copy.\n164         if auto_created:\n165             self.creation_counter = Field.auto_creation_counter\n166             Field.auto_creation_counter -= 1\n167         else:\n168             self.creation_counter = Field.creation_counter\n169             Field.creation_counter += 1\n170 \n171         self._validators = list(validators)  # Store for deconstruction later\n172 \n173         messages = {}\n174         for c in reversed(self.__class__.__mro__):\n175             messages.update(getattr(c, 'default_error_messages', {}))\n176         messages.update(error_messages or {})\n177         self._error_messages = error_messages  # Store for deconstruction later\n178         self.error_messages = messages\n179 \n180     def __str__(self):\n181         \"\"\"\n182         Return \"app_label.model_label.field_name\" for fields attached to\n183         models.\n184         \"\"\"\n185         if not hasattr(self, 'model'):\n186             return super().__str__()\n187         model = self.model\n188         app = model._meta.app_label\n189         return '%s.%s.%s' % (app, model._meta.object_name, self.name)\n190 \n191     def __repr__(self):\n192         \"\"\"Display the module, class, and name of the field.\"\"\"\n193         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)\n194         name = getattr(self, 'name', None)\n195         if name is not None:\n196             return '<%s: %s>' % (path, name)\n197         return '<%s>' % path\n198 \n199     def check(self, **kwargs):\n200         return [\n201             *self._check_field_name(),\n202             *self._check_choices(),\n203             *self._check_db_index(),\n204             *self._check_null_allowed_for_primary_keys(),\n205             *self._check_backend_specific_checks(**kwargs),\n206             *self._check_validators(),\n207             *self._check_deprecation_details(),\n208         ]\n209 \n210     def _check_field_name(self):\n211         \"\"\"\n212         Check if field name is valid, i.e. 1) does not end with an\n213         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n214         \"\"\"\n215         if self.name.endswith('_'):\n216             return [\n217                 checks.Error(\n218                     'Field names must not end with an underscore.',\n219                     obj=self,\n220                     id='fields.E001',\n221                 )\n222             ]\n223         elif LOOKUP_SEP in self.name:\n224             return [\n225                 checks.Error(\n226                     'Field names must not contain \"%s\".' % (LOOKUP_SEP,),\n227                     obj=self,\n228                     id='fields.E002',\n229                 )\n230             ]\n231         elif self.name == 'pk':\n232             return [\n233                 checks.Error(\n234                     \"'pk' is a reserved word that cannot be used as a field name.\",\n235                     obj=self,\n236                     id='fields.E003',\n237                 )\n238             ]\n239         else:\n240             return []\n241 \n242     def _check_choices(self):\n243         if not self.choices:\n244             return []\n245 \n246         def is_value(value, accept_promise=True):\n247             return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n248 \n249         if is_value(self.choices, accept_promise=False):\n250             return [\n251                 checks.Error(\n252                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n253                     obj=self,\n254                     id='fields.E004',\n255                 )\n256             ]\n257 \n258         # Expect [group_name, [value, display]]\n259         for choices_group in self.choices:\n260             try:\n261                 group_name, group_choices = choices_group\n262             except (TypeError, ValueError):\n263                 # Containing non-pairs\n264                 break\n265             try:\n266                 if not all(\n267                     is_value(value) and is_value(human_name)\n268                     for value, human_name in group_choices\n269                 ):\n270                     break\n271             except (TypeError, ValueError):\n272                 # No groups, choices in the form [value, display]\n273                 value, human_name = group_name, group_choices\n274                 if not is_value(value) or not is_value(human_name):\n275                     break\n276 \n277             # Special case: choices=['ab']\n278             if isinstance(choices_group, str):\n279                 break\n280         else:\n281             return []\n282 \n283         return [\n284             checks.Error(\n285                 \"'choices' must be an iterable containing \"\n286                 \"(actual value, human readable name) tuples.\",\n287                 obj=self,\n288                 id='fields.E005',\n289             )\n290         ]\n291 \n292     def _check_db_index(self):\n293         if self.db_index not in (None, True, False):\n294             return [\n295                 checks.Error(\n296                     \"'db_index' must be None, True or False.\",\n297                     obj=self,\n298                     id='fields.E006',\n299                 )\n300             ]\n301         else:\n302             return []\n303 \n304     def _check_null_allowed_for_primary_keys(self):\n305         if (self.primary_key and self.null and\n306                 not connection.features.interprets_empty_strings_as_nulls):\n307             # We cannot reliably check this for backends like Oracle which\n308             # consider NULL and '' to be equal (and thus set up\n309             # character-based fields a little differently).\n310             return [\n311                 checks.Error(\n312                     'Primary keys must not have null=True.',\n313                     hint=('Set null=False on the field, or '\n314                           'remove primary_key=True argument.'),\n315                     obj=self,\n316                     id='fields.E007',\n317                 )\n318             ]\n319         else:\n320             return []\n321 \n322     def _check_backend_specific_checks(self, **kwargs):\n323         app_label = self.model._meta.app_label\n324         for db in connections:\n325             if router.allow_migrate(db, app_label, model_name=self.model._meta.model_name):\n326                 return connections[db].validation.check_field(self, **kwargs)\n327         return []\n328 \n329     def _check_validators(self):\n330         errors = []\n331         for i, validator in enumerate(self.validators):\n332             if not callable(validator):\n333                 errors.append(\n334                     checks.Error(\n335                         \"All 'validators' must be callable.\",\n336                         hint=(\n337                             \"validators[{i}] ({repr}) isn't a function or \"\n338                             \"instance of a validator class.\".format(\n339                                 i=i, repr=repr(validator),\n340                             )\n341                         ),\n342                         obj=self,\n343                         id='fields.E008',\n344                     )\n345                 )\n346         return errors\n347 \n348     def _check_deprecation_details(self):\n349         if self.system_check_removed_details is not None:\n350             return [\n351                 checks.Error(\n352                     self.system_check_removed_details.get(\n353                         'msg',\n354                         '%s has been removed except for support in historical '\n355                         'migrations.' % self.__class__.__name__\n356                     ),\n357                     hint=self.system_check_removed_details.get('hint'),\n358                     obj=self,\n359                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),\n360                 )\n361             ]\n362         elif self.system_check_deprecated_details is not None:\n363             return [\n364                 checks.Warning(\n365                     self.system_check_deprecated_details.get(\n366                         'msg',\n367                         '%s has been deprecated.' % self.__class__.__name__\n368                     ),\n369                     hint=self.system_check_deprecated_details.get('hint'),\n370                     obj=self,\n371                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),\n372                 )\n373             ]\n374         return []\n375 \n376     def get_col(self, alias, output_field=None):\n377         if output_field is None:\n378             output_field = self\n379         if alias != self.model._meta.db_table or output_field != self:\n380             from django.db.models.expressions import Col\n381             return Col(alias, self, output_field)\n382         else:\n383             return self.cached_col\n384 \n385     @cached_property\n386     def cached_col(self):\n387         from django.db.models.expressions import Col\n388         return Col(self.model._meta.db_table, self)\n389 \n390     def select_format(self, compiler, sql, params):\n391         \"\"\"\n392         Custom format for select clauses. For example, GIS columns need to be\n393         selected as AsText(table.col) on MySQL as the table.col data can't be\n394         used by Django.\n395         \"\"\"\n396         return sql, params\n397 \n398     def deconstruct(self):\n399         \"\"\"\n400         Return enough information to recreate the field as a 4-tuple:\n401 \n402          * The name of the field on the model, if contribute_to_class() has\n403            been run.\n404          * The import path of the field, including the class:e.g.\n405            django.db.models.IntegerField This should be the most portable\n406            version, so less specific may be better.\n407          * A list of positional arguments.\n408          * A dict of keyword arguments.\n409 \n410         Note that the positional or keyword arguments must contain values of\n411         the following types (including inner values of collection types):\n412 \n413          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n414            dict\n415          * UUID\n416          * datetime.datetime (naive), datetime.date\n417          * top-level classes, top-level functions - will be referenced by their\n418            full import path\n419          * Storage instances - these have their own deconstruct() method\n420 \n421         This is because the values here must be serialized into a text format\n422         (possibly new Python code, possibly JSON) and these are the only types\n423         with encoding handlers defined.\n424 \n425         There's no need to return the exact way the field was instantiated this\n426         time, just ensure that the resulting field is the same - prefer keyword\n427         arguments over positional ones, and omit parameters with their default\n428         values.\n429         \"\"\"\n430         # Short-form way of fetching all the default parameters\n431         keywords = {}\n432         possibles = {\n433             \"verbose_name\": None,\n434             \"primary_key\": False,\n435             \"max_length\": None,\n436             \"unique\": False,\n437             \"blank\": False,\n438             \"null\": False,\n439             \"db_index\": False,\n440             \"default\": NOT_PROVIDED,\n441             \"editable\": True,\n442             \"serialize\": True,\n443             \"unique_for_date\": None,\n444             \"unique_for_month\": None,\n445             \"unique_for_year\": None,\n446             \"choices\": None,\n447             \"help_text\": '',\n448             \"db_column\": None,\n449             \"db_tablespace\": None,\n450             \"auto_created\": False,\n451             \"validators\": [],\n452             \"error_messages\": None,\n453         }\n454         attr_overrides = {\n455             \"unique\": \"_unique\",\n456             \"error_messages\": \"_error_messages\",\n457             \"validators\": \"_validators\",\n458             \"verbose_name\": \"_verbose_name\",\n459             \"db_tablespace\": \"_db_tablespace\",\n460         }\n461         equals_comparison = {\"choices\", \"validators\"}\n462         for name, default in possibles.items():\n463             value = getattr(self, attr_overrides.get(name, name))\n464             # Unroll anything iterable for choices into a concrete list\n465             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n466                 value = list(value)\n467             # Do correct kind of comparison\n468             if name in equals_comparison:\n469                 if value != default:\n470                     keywords[name] = value\n471             else:\n472                 if value is not default:\n473                     keywords[name] = value\n474         # Work out path - we shorten it for known Django core fields\n475         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n476         if path.startswith(\"django.db.models.fields.related\"):\n477             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n478         if path.startswith(\"django.db.models.fields.files\"):\n479             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n480         if path.startswith(\"django.db.models.fields.proxy\"):\n481             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n482         if path.startswith(\"django.db.models.fields\"):\n483             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n484         # Return basic info - other fields should override this.\n485         return (self.name, path, [], keywords)\n486 \n487     def clone(self):\n488         \"\"\"\n489         Uses deconstruct() to clone a new copy of this Field.\n490         Will not preserve any class attachments/attribute names.\n491         \"\"\"\n492         name, path, args, kwargs = self.deconstruct()\n493         return self.__class__(*args, **kwargs)\n494 \n495     def __eq__(self, other):\n496         # Needed for @total_ordering\n497         if isinstance(other, Field):\n498             return self.creation_counter == other.creation_counter\n499         return NotImplemented\n500 \n501     def __lt__(self, other):\n502         # This is needed because bisect does not take a comparison function.\n503         if isinstance(other, Field):\n504             return self.creation_counter < other.creation_counter\n505         return NotImplemented\n506 \n507     def __hash__(self):\n508         return hash(self.creation_counter)\n509 \n510     def __deepcopy__(self, memodict):\n511         # We don't have to deepcopy very much here, since most things are not\n512         # intended to be altered after initial creation.\n513         obj = copy.copy(self)\n514         if self.remote_field:\n515             obj.remote_field = copy.copy(self.remote_field)\n516             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:\n517                 obj.remote_field.field = obj\n518         memodict[id(self)] = obj\n519         return obj\n520 \n521     def __copy__(self):\n522         # We need to avoid hitting __reduce__, so define this\n523         # slightly weird copy construct.\n524         obj = Empty()\n525         obj.__class__ = self.__class__\n526         obj.__dict__ = self.__dict__.copy()\n527         return obj\n528 \n529     def __reduce__(self):\n530         \"\"\"\n531         Pickling should return the model._meta.fields instance of the field,\n532         not a new copy of that field. So, use the app registry to load the\n533         model and then the field back.\n534         \"\"\"\n535         if not hasattr(self, 'model'):\n536             # Fields are sometimes used without attaching them to models (for\n537             # example in aggregation). In this case give back a plain field\n538             # instance. The code below will create a new empty instance of\n539             # class self.__class__, then update its dict with self.__dict__\n540             # values - so, this is very close to normal pickle.\n541             state = self.__dict__.copy()\n542             # The _get_default cached_property can't be pickled due to lambda\n543             # usage.\n544             state.pop('_get_default', None)\n545             return _empty, (self.__class__,), state\n546         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,\n547                              self.name)\n548 \n549     def get_pk_value_on_save(self, instance):\n550         \"\"\"\n551         Hook to generate new PK values on save. This method is called when\n552         saving instances with no primary key value set. If this method returns\n553         something else than None, then the returned value is used when saving\n554         the new instance.\n555         \"\"\"\n556         if self.default:\n557             return self.get_default()\n558         return None\n559 \n560     def to_python(self, value):\n561         \"\"\"\n562         Convert the input value into the expected Python data type, raising\n563         django.core.exceptions.ValidationError if the data can't be converted.\n564         Return the converted value. Subclasses should override this.\n565         \"\"\"\n566         return value\n567 \n568     @cached_property\n569     def validators(self):\n570         \"\"\"\n571         Some validators can't be created at field initialization time.\n572         This method provides a way to delay their creation until required.\n573         \"\"\"\n574         return [*self.default_validators, *self._validators]\n575 \n576     def run_validators(self, value):\n577         if value in self.empty_values:\n578             return\n579 \n580         errors = []\n581         for v in self.validators:\n582             try:\n583                 v(value)\n584             except exceptions.ValidationError as e:\n585                 if hasattr(e, 'code') and e.code in self.error_messages:\n586                     e.message = self.error_messages[e.code]\n587                 errors.extend(e.error_list)\n588 \n589         if errors:\n590             raise exceptions.ValidationError(errors)\n591 \n592     def validate(self, value, model_instance):\n593         \"\"\"\n594         Validate value and raise ValidationError if necessary. Subclasses\n595         should override this to provide validation logic.\n596         \"\"\"\n597         if not self.editable:\n598             # Skip validation for non-editable fields.\n599             return\n600 \n601         if self.choices is not None and value not in self.empty_values:\n602             for option_key, option_value in self.choices:\n603                 if isinstance(option_value, (list, tuple)):\n604                     # This is an optgroup, so look inside the group for\n605                     # options.\n606                     for optgroup_key, optgroup_value in option_value:\n607                         if value == optgroup_key:\n608                             return\n609                 elif value == option_key:\n610                     return\n611             raise exceptions.ValidationError(\n612                 self.error_messages['invalid_choice'],\n613                 code='invalid_choice',\n614                 params={'value': value},\n615             )\n616 \n617         if value is None and not self.null:\n618             raise exceptions.ValidationError(self.error_messages['null'], code='null')\n619 \n620         if not self.blank and value in self.empty_values:\n621             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')\n622 \n623     def clean(self, value, model_instance):\n624         \"\"\"\n625         Convert the value's type and run validation. Validation errors\n626         from to_python() and validate() are propagated. Return the correct\n627         value if no error is raised.\n628         \"\"\"\n629         value = self.to_python(value)\n630         self.validate(value, model_instance)\n631         self.run_validators(value)\n632         return value\n633 \n634     def db_type_parameters(self, connection):\n635         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')\n636 \n637     def db_check(self, connection):\n638         \"\"\"\n639         Return the database column check constraint for this field, for the\n640         provided connection. Works the same way as db_type() for the case that\n641         get_internal_type() does not map to a preexisting model field.\n642         \"\"\"\n643         data = self.db_type_parameters(connection)\n644         try:\n645             return connection.data_type_check_constraints[self.get_internal_type()] % data\n646         except KeyError:\n647             return None\n648 \n649     def db_type(self, connection):\n650         \"\"\"\n651         Return the database column data type for this field, for the provided\n652         connection.\n653         \"\"\"\n654         # The default implementation of this method looks at the\n655         # backend-specific data_types dictionary, looking up the field by its\n656         # \"internal type\".\n657         #\n658         # A Field class can implement the get_internal_type() method to specify\n659         # which *preexisting* Django Field class it's most similar to -- i.e.,\n660         # a custom field might be represented by a TEXT column type, which is\n661         # the same as the TextField Django field type, which means the custom\n662         # field's get_internal_type() returns 'TextField'.\n663         #\n664         # But the limitation of the get_internal_type() / data_types approach\n665         # is that it cannot handle database column types that aren't already\n666         # mapped to one of the built-in Django field types. In this case, you\n667         # can implement db_type() instead of get_internal_type() to specify\n668         # exactly which wacky database column type you want to use.\n669         data = self.db_type_parameters(connection)\n670         try:\n671             return connection.data_types[self.get_internal_type()] % data\n672         except KeyError:\n673             return None\n674 \n675     def rel_db_type(self, connection):\n676         \"\"\"\n677         Return the data type that a related field pointing to this field should\n678         use. For example, this method is called by ForeignKey and OneToOneField\n679         to determine its data type.\n680         \"\"\"\n681         return self.db_type(connection)\n682 \n683     def cast_db_type(self, connection):\n684         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n685         db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n686         if db_type:\n687             return db_type % self.db_type_parameters(connection)\n688         return self.db_type(connection)\n689 \n690     def db_parameters(self, connection):\n691         \"\"\"\n692         Extension of db_type(), providing a range of different return values\n693         (type, checks). This will look at db_type(), allowing custom model\n694         fields to override it.\n695         \"\"\"\n696         type_string = self.db_type(connection)\n697         check_string = self.db_check(connection)\n698         return {\n699             \"type\": type_string,\n700             \"check\": check_string,\n701         }\n702 \n703     def db_type_suffix(self, connection):\n704         return connection.data_types_suffix.get(self.get_internal_type())\n705 \n706     def get_db_converters(self, connection):\n707         if hasattr(self, 'from_db_value'):\n708             return [self.from_db_value]\n709         return []\n710 \n711     @property\n712     def unique(self):\n713         return self._unique or self.primary_key\n714 \n715     @property\n716     def db_tablespace(self):\n717         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n718 \n719     def set_attributes_from_name(self, name):\n720         self.name = self.name or name\n721         self.attname, self.column = self.get_attname_column()\n722         self.concrete = self.column is not None\n723         if self.verbose_name is None and self.name:\n724             self.verbose_name = self.name.replace('_', ' ')\n725 \n726     def contribute_to_class(self, cls, name, private_only=False):\n727         \"\"\"\n728         Register the field with the model class it belongs to.\n729 \n730         If private_only is True, create a separate instance of this field\n731         for every subclass of cls, even if cls is not an abstract model.\n732         \"\"\"\n733         self.set_attributes_from_name(name)\n734         self.model = cls\n735         cls._meta.add_field(self, private=private_only)\n736         if self.column:\n737             # Don't override classmethods with the descriptor. This means that\n738             # if you have a classmethod and a field with the same name, then\n739             # such fields can't be deferred (we don't have a check for this).\n740             if not getattr(cls, self.attname, None):\n741                 setattr(cls, self.attname, DeferredAttribute(self.attname))\n742         if self.choices is not None:\n743             setattr(cls, 'get_%s_display' % self.name,\n744                     partialmethod(cls._get_FIELD_display, field=self))\n745 \n746     def get_filter_kwargs_for_object(self, obj):\n747         \"\"\"\n748         Return a dict that when passed as kwargs to self.model.filter(), would\n749         yield all instances having the same value for this field as obj has.\n750         \"\"\"\n751         return {self.name: getattr(obj, self.attname)}\n752 \n753     def get_attname(self):\n754         return self.name\n755 \n756     def get_attname_column(self):\n757         attname = self.get_attname()\n758         column = self.db_column or attname\n759         return attname, column\n760 \n761     def get_internal_type(self):\n762         return self.__class__.__name__\n763 \n764     def pre_save(self, model_instance, add):\n765         \"\"\"Return field's value just before saving.\"\"\"\n766         return getattr(model_instance, self.attname)\n767 \n768     def get_prep_value(self, value):\n769         \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n770         if isinstance(value, Promise):\n771             value = value._proxy____cast()\n772         return value\n773 \n774     def get_db_prep_value(self, value, connection, prepared=False):\n775         \"\"\"\n776         Return field's value prepared for interacting with the database backend.\n777 \n778         Used by the default implementations of get_db_prep_save().\n779         \"\"\"\n780         if not prepared:\n781             value = self.get_prep_value(value)\n782         return value\n783 \n784     def get_db_prep_save(self, value, connection):\n785         \"\"\"Return field's value prepared for saving into a database.\"\"\"\n786         return self.get_db_prep_value(value, connection=connection, prepared=False)\n787 \n788     def has_default(self):\n789         \"\"\"Return a boolean of whether this field has a default value.\"\"\"\n790         return self.default is not NOT_PROVIDED\n791 \n792     def get_default(self):\n793         \"\"\"Return the default value for this field.\"\"\"\n794         return self._get_default()\n795 \n796     @cached_property\n797     def _get_default(self):\n798         if self.has_default():\n799             if callable(self.default):\n800                 return self.default\n801             return lambda: self.default\n802 \n803         if not self.empty_strings_allowed or self.null and not connection.features.interprets_empty_strings_as_nulls:\n804             return return_None\n805         return str  # return empty string\n806 \n807     def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None, ordering=()):\n808         \"\"\"\n809         Return choices with a default blank choices included, for use\n810         as <select> choices for this field.\n811         \"\"\"\n812         if self.choices is not None:\n813             choices = list(self.choices)\n814             if include_blank:\n815                 blank_defined = any(choice in ('', None) for choice, _ in self.flatchoices)\n816                 if not blank_defined:\n817                     choices = blank_choice + choices\n818             return choices\n819         rel_model = self.remote_field.model\n820         limit_choices_to = limit_choices_to or self.get_limit_choices_to()\n821         choice_func = operator.attrgetter(\n822             self.remote_field.get_related_field().attname\n823             if hasattr(self.remote_field, 'get_related_field')\n824             else 'pk'\n825         )\n826         return (blank_choice if include_blank else []) + [\n827             (choice_func(x), str(x))\n828             for x in rel_model._default_manager.complex_filter(limit_choices_to).order_by(*ordering)\n829         ]\n830 \n831     def value_to_string(self, obj):\n832         \"\"\"\n833         Return a string value of this field from the passed obj.\n834         This is used by the serialization framework.\n835         \"\"\"\n836         return str(self.value_from_object(obj))\n837 \n838     def _get_flatchoices(self):\n839         \"\"\"Flattened version of choices tuple.\"\"\"\n840         if self.choices is None:\n841             return []\n842         flat = []\n843         for choice, value in self.choices:\n844             if isinstance(value, (list, tuple)):\n845                 flat.extend(value)\n846             else:\n847                 flat.append((choice, value))\n848         return flat\n849     flatchoices = property(_get_flatchoices)\n850 \n851     def save_form_data(self, instance, data):\n852         setattr(instance, self.name, data)\n853 \n854     def formfield(self, form_class=None, choices_form_class=None, **kwargs):\n855         \"\"\"Return a django.forms.Field instance for this field.\"\"\"\n856         defaults = {\n857             'required': not self.blank,\n858             'label': capfirst(self.verbose_name),\n859             'help_text': self.help_text,\n860         }\n861         if self.has_default():\n862             if callable(self.default):\n863                 defaults['initial'] = self.default\n864                 defaults['show_hidden_initial'] = True\n865             else:\n866                 defaults['initial'] = self.get_default()\n867         if self.choices is not None:\n868             # Fields with choices get special treatment.\n869             include_blank = (self.blank or\n870                              not (self.has_default() or 'initial' in kwargs))\n871             defaults['choices'] = self.get_choices(include_blank=include_blank)\n872             defaults['coerce'] = self.to_python\n873             if self.null:\n874                 defaults['empty_value'] = None\n875             if choices_form_class is not None:\n876                 form_class = choices_form_class\n877             else:\n878                 form_class = forms.TypedChoiceField\n879             # Many of the subclass-specific formfield arguments (min_value,\n880             # max_value) don't apply for choice fields, so be sure to only pass\n881             # the values that TypedChoiceField will understand.\n882             for k in list(kwargs):\n883                 if k not in ('coerce', 'empty_value', 'choices', 'required',\n884                              'widget', 'label', 'initial', 'help_text',\n885                              'error_messages', 'show_hidden_initial', 'disabled'):\n886                     del kwargs[k]\n887         defaults.update(kwargs)\n888         if form_class is None:\n889             form_class = forms.CharField\n890         return form_class(**defaults)\n891 \n892     def value_from_object(self, obj):\n893         \"\"\"Return the value of this field in the given model instance.\"\"\"\n894         return getattr(obj, self.attname)\n895 \n896 \n897 class AutoField(Field):\n898     description = _(\"Integer\")\n899 \n900     empty_strings_allowed = False\n901     default_error_messages = {\n902         'invalid': _(\"'%(value)s' value must be an integer.\"),\n903     }\n904 \n905     def __init__(self, *args, **kwargs):\n906         kwargs['blank'] = True\n907         super().__init__(*args, **kwargs)\n908 \n909     def check(self, **kwargs):\n910         return [\n911             *super().check(**kwargs),\n912             *self._check_primary_key(),\n913         ]\n914 \n915     def _check_primary_key(self):\n916         if not self.primary_key:\n917             return [\n918                 checks.Error(\n919                     'AutoFields must set primary_key=True.',\n920                     obj=self,\n921                     id='fields.E100',\n922                 ),\n923             ]\n924         else:\n925             return []\n926 \n927     def deconstruct(self):\n928         name, path, args, kwargs = super().deconstruct()\n929         del kwargs['blank']\n930         kwargs['primary_key'] = True\n931         return name, path, args, kwargs\n932 \n933     def get_internal_type(self):\n934         return \"AutoField\"\n935 \n936     def to_python(self, value):\n937         if value is None:\n938             return value\n939         try:\n940             return int(value)\n941         except (TypeError, ValueError):\n942             raise exceptions.ValidationError(\n943                 self.error_messages['invalid'],\n944                 code='invalid',\n945                 params={'value': value},\n946             )\n947 \n948     def rel_db_type(self, connection):\n949         return IntegerField().db_type(connection=connection)\n950 \n951     def validate(self, value, model_instance):\n952         pass\n953 \n954     def get_db_prep_value(self, value, connection, prepared=False):\n955         if not prepared:\n956             value = self.get_prep_value(value)\n957             value = connection.ops.validate_autopk_value(value)\n958         return value\n959 \n960     def get_prep_value(self, value):\n961         from django.db.models.expressions import OuterRef\n962         value = super().get_prep_value(value)\n963         if value is None or isinstance(value, OuterRef):\n964             return value\n965         return int(value)\n966 \n967     def contribute_to_class(self, cls, name, **kwargs):\n968         assert not cls._meta.auto_field, \"Model %s can't have more than one AutoField.\" % cls._meta.label\n969         super().contribute_to_class(cls, name, **kwargs)\n970         cls._meta.auto_field = self\n971 \n972     def formfield(self, **kwargs):\n973         return None\n974 \n975 \n976 class BigAutoField(AutoField):\n977     description = _(\"Big (8 byte) integer\")\n978 \n979     def get_internal_type(self):\n980         return \"BigAutoField\"\n981 \n982     def rel_db_type(self, connection):\n983         return BigIntegerField().db_type(connection=connection)\n984 \n985 \n986 class BooleanField(Field):\n987     empty_strings_allowed = False\n988     default_error_messages = {\n989         'invalid': _(\"'%(value)s' value must be either True or False.\"),\n990         'invalid_nullable': _(\"'%(value)s' value must be either True, False, or None.\"),\n991     }\n992     description = _(\"Boolean (Either True or False)\")\n993 \n994     def get_internal_type(self):\n995         return \"BooleanField\"\n996 \n997     def to_python(self, value):\n998         if self.null and value in self.empty_values:\n999             return None\n1000         if value in (True, False):\n1001             # 1/0 are equal to True/False. bool() converts former to latter.\n1002             return bool(value)\n1003         if value in ('t', 'True', '1'):\n1004             return True\n1005         if value in ('f', 'False', '0'):\n1006             return False\n1007         raise exceptions.ValidationError(\n1008             self.error_messages['invalid_nullable' if self.null else 'invalid'],\n1009             code='invalid',\n1010             params={'value': value},\n1011         )\n1012 \n1013     def get_prep_value(self, value):\n1014         value = super().get_prep_value(value)\n1015         if value is None:\n1016             return None\n1017         return self.to_python(value)\n1018 \n1019     def formfield(self, **kwargs):\n1020         if self.choices is not None:\n1021             include_blank = not (self.has_default() or 'initial' in kwargs)\n1022             defaults = {'choices': self.get_choices(include_blank=include_blank)}\n1023         else:\n1024             form_class = forms.NullBooleanField if self.null else forms.BooleanField\n1025             # In HTML checkboxes, 'required' means \"must be checked\" which is\n1026             # different from the choices case (\"must select some value\").\n1027             # required=False allows unchecked checkboxes.\n1028             defaults = {'form_class': form_class, 'required': False}\n1029         return super().formfield(**{**defaults, **kwargs})\n1030 \n1031 \n1032 class CharField(Field):\n1033     description = _(\"String (up to %(max_length)s)\")\n1034 \n1035     def __init__(self, *args, **kwargs):\n1036         super().__init__(*args, **kwargs)\n1037         self.validators.append(validators.MaxLengthValidator(self.max_length))\n1038 \n1039     def check(self, **kwargs):\n1040         return [\n1041             *super().check(**kwargs),\n1042             *self._check_max_length_attribute(**kwargs),\n1043         ]\n1044 \n1045     def _check_max_length_attribute(self, **kwargs):\n1046         if self.max_length is None:\n1047             return [\n1048                 checks.Error(\n1049                     \"CharFields must define a 'max_length' attribute.\",\n1050                     obj=self,\n1051                     id='fields.E120',\n1052                 )\n1053             ]\n1054         elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n1055                 self.max_length <= 0):\n1056             return [\n1057                 checks.Error(\n1058                     \"'max_length' must be a positive integer.\",\n1059                     obj=self,\n1060                     id='fields.E121',\n1061                 )\n1062             ]\n1063         else:\n1064             return []\n1065 \n1066     def cast_db_type(self, connection):\n1067         if self.max_length is None:\n1068             return connection.ops.cast_char_field_without_max_length\n1069         return super().cast_db_type(connection)\n1070 \n1071     def get_internal_type(self):\n1072         return \"CharField\"\n1073 \n1074     def to_python(self, value):\n1075         if isinstance(value, str) or value is None:\n1076             return value\n1077         return str(value)\n1078 \n1079     def get_prep_value(self, value):\n1080         value = super().get_prep_value(value)\n1081         return self.to_python(value)\n1082 \n1083     def formfield(self, **kwargs):\n1084         # Passing max_length to forms.CharField means that the value's length\n1085         # will be validated twice. This is considered acceptable since we want\n1086         # the value in the form field (to pass into widget for example).\n1087         defaults = {'max_length': self.max_length}\n1088         # TODO: Handle multiple backends with different feature flags.\n1089         if self.null and not connection.features.interprets_empty_strings_as_nulls:\n1090             defaults['empty_value'] = None\n1091         defaults.update(kwargs)\n1092         return super().formfield(**defaults)\n1093 \n1094 \n1095 class CommaSeparatedIntegerField(CharField):\n1096     default_validators = [validators.validate_comma_separated_integer_list]\n1097     description = _(\"Comma-separated integers\")\n1098     system_check_removed_details = {\n1099         'msg': (\n1100             'CommaSeparatedIntegerField is removed except for support in '\n1101             'historical migrations.'\n1102         ),\n1103         'hint': (\n1104             'Use CharField(validators=[validate_comma_separated_integer_list]) '\n1105             'instead.'\n1106         ),\n1107         'id': 'fields.E901',\n1108     }\n1109 \n1110 \n1111 class DateTimeCheckMixin:\n1112 \n1113     def check(self, **kwargs):\n1114         return [\n1115             *super().check(**kwargs),\n1116             *self._check_mutually_exclusive_options(),\n1117             *self._check_fix_default_value(),\n1118         ]\n1119 \n1120     def _check_mutually_exclusive_options(self):\n1121         # auto_now, auto_now_add, and default are mutually exclusive\n1122         # options. The use of more than one of these options together\n1123         # will trigger an Error\n1124         mutually_exclusive_options = [self.auto_now_add, self.auto_now, self.has_default()]\n1125         enabled_options = [option not in (None, False) for option in mutually_exclusive_options].count(True)\n1126         if enabled_options > 1:\n1127             return [\n1128                 checks.Error(\n1129                     \"The options auto_now, auto_now_add, and default \"\n1130                     \"are mutually exclusive. Only one of these options \"\n1131                     \"may be present.\",\n1132                     obj=self,\n1133                     id='fields.E160',\n1134                 )\n1135             ]\n1136         else:\n1137             return []\n1138 \n1139     def _check_fix_default_value(self):\n1140         return []\n1141 \n1142 \n1143 class DateField(DateTimeCheckMixin, Field):\n1144     empty_strings_allowed = False\n1145     default_error_messages = {\n1146         'invalid': _(\"'%(value)s' value has an invalid date format. It must be \"\n1147                      \"in YYYY-MM-DD format.\"),\n1148         'invalid_date': _(\"'%(value)s' value has the correct format (YYYY-MM-DD) \"\n1149                           \"but it is an invalid date.\"),\n1150     }\n1151     description = _(\"Date (without time)\")\n1152 \n1153     def __init__(self, verbose_name=None, name=None, auto_now=False,\n1154                  auto_now_add=False, **kwargs):\n1155         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n1156         if auto_now or auto_now_add:\n1157             kwargs['editable'] = False\n1158             kwargs['blank'] = True\n1159         super().__init__(verbose_name, name, **kwargs)\n1160 \n1161     def _check_fix_default_value(self):\n1162         \"\"\"\n1163         Warn that using an actual date or datetime value is probably wrong;\n1164         it's only evaluated on server startup.\n1165         \"\"\"\n1166         if not self.has_default():\n1167             return []\n1168 \n1169         now = timezone.now()\n1170         if not timezone.is_naive(now):\n1171             now = timezone.make_naive(now, timezone.utc)\n1172         value = self.default\n1173         if isinstance(value, datetime.datetime):\n1174             if not timezone.is_naive(value):\n1175                 value = timezone.make_naive(value, timezone.utc)\n1176             value = value.date()\n1177         elif isinstance(value, datetime.date):\n1178             # Nothing to do, as dates don't have tz information\n1179             pass\n1180         else:\n1181             # No explicit date / datetime value -- no checks necessary\n1182             return []\n1183         offset = datetime.timedelta(days=1)\n1184         lower = (now - offset).date()\n1185         upper = (now + offset).date()\n1186         if lower <= value <= upper:\n1187             return [\n1188                 checks.Warning(\n1189                     'Fixed default value provided.',\n1190                     hint='It seems you set a fixed date / time / datetime '\n1191                          'value as default for this field. This may not be '\n1192                          'what you want. If you want to have the current date '\n1193                          'as default, use `django.utils.timezone.now`',\n1194                     obj=self,\n1195                     id='fields.W161',\n1196                 )\n1197             ]\n1198 \n1199         return []\n1200 \n1201     def deconstruct(self):\n1202         name, path, args, kwargs = super().deconstruct()\n1203         if self.auto_now:\n1204             kwargs['auto_now'] = True\n1205         if self.auto_now_add:\n1206             kwargs['auto_now_add'] = True\n1207         if self.auto_now or self.auto_now_add:\n1208             del kwargs['editable']\n1209             del kwargs['blank']\n1210         return name, path, args, kwargs\n1211 \n1212     def get_internal_type(self):\n1213         return \"DateField\"\n1214 \n1215     def to_python(self, value):\n1216         if value is None:\n1217             return value\n1218         if isinstance(value, datetime.datetime):\n1219             if settings.USE_TZ and timezone.is_aware(value):\n1220                 # Convert aware datetimes to the default time zone\n1221                 # before casting them to dates (#17742).\n1222                 default_timezone = timezone.get_default_timezone()\n1223                 value = timezone.make_naive(value, default_timezone)\n1224             return value.date()\n1225         if isinstance(value, datetime.date):\n1226             return value\n1227 \n1228         try:\n1229             parsed = parse_date(value)\n1230             if parsed is not None:\n1231                 return parsed\n1232         except ValueError:\n1233             raise exceptions.ValidationError(\n1234                 self.error_messages['invalid_date'],\n1235                 code='invalid_date',\n1236                 params={'value': value},\n1237             )\n1238 \n1239         raise exceptions.ValidationError(\n1240             self.error_messages['invalid'],\n1241             code='invalid',\n1242             params={'value': value},\n1243         )\n1244 \n1245     def pre_save(self, model_instance, add):\n1246         if self.auto_now or (self.auto_now_add and add):\n1247             value = datetime.date.today()\n1248             setattr(model_instance, self.attname, value)\n1249             return value\n1250         else:\n1251             return super().pre_save(model_instance, add)\n1252 \n1253     def contribute_to_class(self, cls, name, **kwargs):\n1254         super().contribute_to_class(cls, name, **kwargs)\n1255         if not self.null:\n1256             setattr(\n1257                 cls, 'get_next_by_%s' % self.name,\n1258                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=True)\n1259             )\n1260             setattr(\n1261                 cls, 'get_previous_by_%s' % self.name,\n1262                 partialmethod(cls._get_next_or_previous_by_FIELD, field=self, is_next=False)\n1263             )\n1264 \n1265     def get_prep_value(self, value):\n1266         value = super().get_prep_value(value)\n1267         return self.to_python(value)\n1268 \n1269     def get_db_prep_value(self, value, connection, prepared=False):\n1270         # Casts dates into the format expected by the backend\n1271         if not prepared:\n1272             value = self.get_prep_value(value)\n1273         return connection.ops.adapt_datefield_value(value)\n1274 \n1275     def value_to_string(self, obj):\n1276         val = self.value_from_object(obj)\n1277         return '' if val is None else val.isoformat()\n1278 \n1279     def formfield(self, **kwargs):\n1280         return super().formfield(**{\n1281             'form_class': forms.DateField,\n1282             **kwargs,\n1283         })\n1284 \n1285 \n1286 class DateTimeField(DateField):\n1287     empty_strings_allowed = False\n1288     default_error_messages = {\n1289         'invalid': _(\"'%(value)s' value has an invalid format. It must be in \"\n1290                      \"YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] format.\"),\n1291         'invalid_date': _(\"'%(value)s' value has the correct format \"\n1292                           \"(YYYY-MM-DD) but it is an invalid date.\"),\n1293         'invalid_datetime': _(\"'%(value)s' value has the correct format \"\n1294                               \"(YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]) \"\n1295                               \"but it is an invalid date/time.\"),\n1296     }\n1297     description = _(\"Date (with time)\")\n1298 \n1299     # __init__ is inherited from DateField\n1300 \n1301     def _check_fix_default_value(self):\n1302         \"\"\"\n1303         Warn that using an actual date or datetime value is probably wrong;\n1304         it's only evaluated on server startup.\n1305         \"\"\"\n1306         if not self.has_default():\n1307             return []\n1308 \n1309         now = timezone.now()\n1310         if not timezone.is_naive(now):\n1311             now = timezone.make_naive(now, timezone.utc)\n1312         value = self.default\n1313         if isinstance(value, datetime.datetime):\n1314             second_offset = datetime.timedelta(seconds=10)\n1315             lower = now - second_offset\n1316             upper = now + second_offset\n1317             if timezone.is_aware(value):\n1318                 value = timezone.make_naive(value, timezone.utc)\n1319         elif isinstance(value, datetime.date):\n1320             second_offset = datetime.timedelta(seconds=10)\n1321             lower = now - second_offset\n1322             lower = datetime.datetime(lower.year, lower.month, lower.day)\n1323             upper = now + second_offset\n1324             upper = datetime.datetime(upper.year, upper.month, upper.day)\n1325             value = datetime.datetime(value.year, value.month, value.day)\n1326         else:\n1327             # No explicit date / datetime value -- no checks necessary\n1328             return []\n1329         if lower <= value <= upper:\n1330             return [\n1331                 checks.Warning(\n1332                     'Fixed default value provided.',\n1333                     hint='It seems you set a fixed date / time / datetime '\n1334                          'value as default for this field. This may not be '\n1335                          'what you want. If you want to have the current date '\n1336                          'as default, use `django.utils.timezone.now`',\n1337                     obj=self,\n1338                     id='fields.W161',\n1339                 )\n1340             ]\n1341 \n1342         return []\n1343 \n1344     def get_internal_type(self):\n1345         return \"DateTimeField\"\n1346 \n1347     def to_python(self, value):\n1348         if value is None:\n1349             return value\n1350         if isinstance(value, datetime.datetime):\n1351             return value\n1352         if isinstance(value, datetime.date):\n1353             value = datetime.datetime(value.year, value.month, value.day)\n1354             if settings.USE_TZ:\n1355                 # For backwards compatibility, interpret naive datetimes in\n1356                 # local time. This won't work during DST change, but we can't\n1357                 # do much about it, so we let the exceptions percolate up the\n1358                 # call stack.\n1359                 warnings.warn(\"DateTimeField %s.%s received a naive datetime \"\n1360                               \"(%s) while time zone support is active.\" %\n1361                               (self.model.__name__, self.name, value),\n1362                               RuntimeWarning)\n1363                 default_timezone = timezone.get_default_timezone()\n1364                 value = timezone.make_aware(value, default_timezone)\n1365             return value\n1366 \n1367         try:\n1368             parsed = parse_datetime(value)\n1369             if parsed is not None:\n1370                 return parsed\n1371         except ValueError:\n1372             raise exceptions.ValidationError(\n1373                 self.error_messages['invalid_datetime'],\n1374                 code='invalid_datetime',\n1375                 params={'value': value},\n1376             )\n1377 \n1378         try:\n1379             parsed = parse_date(value)\n1380             if parsed is not None:\n1381                 return datetime.datetime(parsed.year, parsed.month, parsed.day)\n1382         except ValueError:\n1383             raise exceptions.ValidationError(\n1384                 self.error_messages['invalid_date'],\n1385                 code='invalid_date',\n1386                 params={'value': value},\n1387             )\n1388 \n1389         raise exceptions.ValidationError(\n1390             self.error_messages['invalid'],\n1391             code='invalid',\n1392             params={'value': value},\n1393         )\n1394 \n1395     def pre_save(self, model_instance, add):\n1396         if self.auto_now or (self.auto_now_add and add):\n1397             value = timezone.now()\n1398             setattr(model_instance, self.attname, value)\n1399             return value\n1400         else:\n1401             return super().pre_save(model_instance, add)\n1402 \n1403     # contribute_to_class is inherited from DateField, it registers\n1404     # get_next_by_FOO and get_prev_by_FOO\n1405 \n1406     def get_prep_value(self, value):\n1407         value = super().get_prep_value(value)\n1408         value = self.to_python(value)\n1409         if value is not None and settings.USE_TZ and timezone.is_naive(value):\n1410             # For backwards compatibility, interpret naive datetimes in local\n1411             # time. This won't work during DST change, but we can't do much\n1412             # about it, so we let the exceptions percolate up the call stack.\n1413             try:\n1414                 name = '%s.%s' % (self.model.__name__, self.name)\n1415             except AttributeError:\n1416                 name = '(unbound)'\n1417             warnings.warn(\"DateTimeField %s received a naive datetime (%s)\"\n1418                           \" while time zone support is active.\" %\n1419                           (name, value),\n1420                           RuntimeWarning)\n1421             default_timezone = timezone.get_default_timezone()\n1422             value = timezone.make_aware(value, default_timezone)\n1423         return value\n1424 \n1425     def get_db_prep_value(self, value, connection, prepared=False):\n1426         # Casts datetimes into the format expected by the backend\n1427         if not prepared:\n1428             value = self.get_prep_value(value)\n1429         return connection.ops.adapt_datetimefield_value(value)\n1430 \n1431     def value_to_string(self, obj):\n1432         val = self.value_from_object(obj)\n1433         return '' if val is None else val.isoformat()\n1434 \n1435     def formfield(self, **kwargs):\n1436         return super().formfield(**{\n1437             'form_class': forms.DateTimeField,\n1438             **kwargs,\n1439         })\n1440 \n1441 \n1442 class DecimalField(Field):\n1443     empty_strings_allowed = False\n1444     default_error_messages = {\n1445         'invalid': _(\"'%(value)s' value must be a decimal number.\"),\n1446     }\n1447     description = _(\"Decimal number\")\n1448 \n1449     def __init__(self, verbose_name=None, name=None, max_digits=None,\n1450                  decimal_places=None, **kwargs):\n1451         self.max_digits, self.decimal_places = max_digits, decimal_places\n1452         super().__init__(verbose_name, name, **kwargs)\n1453 \n1454     def check(self, **kwargs):\n1455         errors = super().check(**kwargs)\n1456 \n1457         digits_errors = [\n1458             *self._check_decimal_places(),\n1459             *self._check_max_digits(),\n1460         ]\n1461         if not digits_errors:\n1462             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1463         else:\n1464             errors.extend(digits_errors)\n1465         return errors\n1466 \n1467     def _check_decimal_places(self):\n1468         try:\n1469             decimal_places = int(self.decimal_places)\n1470             if decimal_places < 0:\n1471                 raise ValueError()\n1472         except TypeError:\n1473             return [\n1474                 checks.Error(\n1475                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1476                     obj=self,\n1477                     id='fields.E130',\n1478                 )\n1479             ]\n1480         except ValueError:\n1481             return [\n1482                 checks.Error(\n1483                     \"'decimal_places' must be a non-negative integer.\",\n1484                     obj=self,\n1485                     id='fields.E131',\n1486                 )\n1487             ]\n1488         else:\n1489             return []\n1490 \n1491     def _check_max_digits(self):\n1492         try:\n1493             max_digits = int(self.max_digits)\n1494             if max_digits <= 0:\n1495                 raise ValueError()\n1496         except TypeError:\n1497             return [\n1498                 checks.Error(\n1499                     \"DecimalFields must define a 'max_digits' attribute.\",\n1500                     obj=self,\n1501                     id='fields.E132',\n1502                 )\n1503             ]\n1504         except ValueError:\n1505             return [\n1506                 checks.Error(\n1507                     \"'max_digits' must be a positive integer.\",\n1508                     obj=self,\n1509                     id='fields.E133',\n1510                 )\n1511             ]\n1512         else:\n1513             return []\n1514 \n1515     def _check_decimal_places_and_max_digits(self, **kwargs):\n1516         if int(self.decimal_places) > int(self.max_digits):\n1517             return [\n1518                 checks.Error(\n1519                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1520                     obj=self,\n1521                     id='fields.E134',\n1522                 )\n1523             ]\n1524         return []\n1525 \n1526     @cached_property\n1527     def validators(self):\n1528         return super().validators + [\n1529             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1530         ]\n1531 \n1532     @cached_property\n1533     def context(self):\n1534         return decimal.Context(prec=self.max_digits)\n1535 \n1536     def deconstruct(self):\n1537         name, path, args, kwargs = super().deconstruct()\n1538         if self.max_digits is not None:\n1539             kwargs['max_digits'] = self.max_digits\n1540         if self.decimal_places is not None:\n1541             kwargs['decimal_places'] = self.decimal_places\n1542         return name, path, args, kwargs\n1543 \n1544     def get_internal_type(self):\n1545         return \"DecimalField\"\n1546 \n1547     def to_python(self, value):\n1548         if value is None:\n1549             return value\n1550         if isinstance(value, float):\n1551             return self.context.create_decimal_from_float(value)\n1552         try:\n1553             return decimal.Decimal(value)\n1554         except decimal.InvalidOperation:\n1555             raise exceptions.ValidationError(\n1556                 self.error_messages['invalid'],\n1557                 code='invalid',\n1558                 params={'value': value},\n1559             )\n1560 \n1561     def get_db_prep_save(self, value, connection):\n1562         return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)\n1563 \n1564     def get_prep_value(self, value):\n1565         value = super().get_prep_value(value)\n1566         return self.to_python(value)\n1567 \n1568     def formfield(self, **kwargs):\n1569         return super().formfield(**{\n1570             'max_digits': self.max_digits,\n1571             'decimal_places': self.decimal_places,\n1572             'form_class': forms.DecimalField,\n1573             **kwargs,\n1574         })\n1575 \n1576 \n1577 class DurationField(Field):\n1578     \"\"\"\n1579     Store timedelta objects.\n1580 \n1581     Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint\n1582     of microseconds on other databases.\n1583     \"\"\"\n1584     empty_strings_allowed = False\n1585     default_error_messages = {\n1586         'invalid': _(\"'%(value)s' value has an invalid format. It must be in \"\n1587                      \"[DD] [[HH:]MM:]ss[.uuuuuu] format.\")\n1588     }\n1589     description = _(\"Duration\")\n1590 \n1591     def get_internal_type(self):\n1592         return \"DurationField\"\n1593 \n1594     def to_python(self, value):\n1595         if value is None:\n1596             return value\n1597         if isinstance(value, datetime.timedelta):\n1598             return value\n1599         try:\n1600             parsed = parse_duration(value)\n1601         except ValueError:\n1602             pass\n1603         else:\n1604             if parsed is not None:\n1605                 return parsed\n1606 \n1607         raise exceptions.ValidationError(\n1608             self.error_messages['invalid'],\n1609             code='invalid',\n1610             params={'value': value},\n1611         )\n1612 \n1613     def get_db_prep_value(self, value, connection, prepared=False):\n1614         if connection.features.has_native_duration_field:\n1615             return value\n1616         if value is None:\n1617             return None\n1618         return duration_microseconds(value)\n1619 \n1620     def get_db_converters(self, connection):\n1621         converters = []\n1622         if not connection.features.has_native_duration_field:\n1623             converters.append(connection.ops.convert_durationfield_value)\n1624         return converters + super().get_db_converters(connection)\n1625 \n1626     def value_to_string(self, obj):\n1627         val = self.value_from_object(obj)\n1628         return '' if val is None else duration_string(val)\n1629 \n1630     def formfield(self, **kwargs):\n1631         return super().formfield(**{\n1632             'form_class': forms.DurationField,\n1633             **kwargs,\n1634         })\n1635 \n1636 \n1637 class EmailField(CharField):\n1638     default_validators = [validators.validate_email]\n1639     description = _(\"Email address\")\n1640 \n1641     def __init__(self, *args, **kwargs):\n1642         # max_length=254 to be compliant with RFCs 3696 and 5321\n1643         kwargs.setdefault('max_length', 254)\n1644         super().__init__(*args, **kwargs)\n1645 \n1646     def deconstruct(self):\n1647         name, path, args, kwargs = super().deconstruct()\n1648         # We do not exclude max_length if it matches default as we want to change\n1649         # the default in future.\n1650         return name, path, args, kwargs\n1651 \n1652     def formfield(self, **kwargs):\n1653         # As with CharField, this will cause email validation to be performed\n1654         # twice.\n1655         return super().formfield(**{\n1656             'form_class': forms.EmailField,\n1657             **kwargs,\n1658         })\n1659 \n1660 \n1661 class FilePathField(Field):\n1662     description = _(\"File path\")\n1663 \n1664     def __init__(self, verbose_name=None, name=None, path='', match=None,\n1665                  recursive=False, allow_files=True, allow_folders=False, **kwargs):\n1666         self.path, self.match, self.recursive = path, match, recursive\n1667         self.allow_files, self.allow_folders = allow_files, allow_folders\n1668         kwargs.setdefault('max_length', 100)\n1669         super().__init__(verbose_name, name, **kwargs)\n1670 \n1671     def check(self, **kwargs):\n1672         return [\n1673             *super().check(**kwargs),\n1674             *self._check_allowing_files_or_folders(**kwargs),\n1675         ]\n1676 \n1677     def _check_allowing_files_or_folders(self, **kwargs):\n1678         if not self.allow_files and not self.allow_folders:\n1679             return [\n1680                 checks.Error(\n1681                     \"FilePathFields must have either 'allow_files' or 'allow_folders' set to True.\",\n1682                     obj=self,\n1683                     id='fields.E140',\n1684                 )\n1685             ]\n1686         return []\n1687 \n1688     def deconstruct(self):\n1689         name, path, args, kwargs = super().deconstruct()\n1690         if self.path != '':\n1691             kwargs['path'] = self.path\n1692         if self.match is not None:\n1693             kwargs['match'] = self.match\n1694         if self.recursive is not False:\n1695             kwargs['recursive'] = self.recursive\n1696         if self.allow_files is not True:\n1697             kwargs['allow_files'] = self.allow_files\n1698         if self.allow_folders is not False:\n1699             kwargs['allow_folders'] = self.allow_folders\n1700         if kwargs.get(\"max_length\") == 100:\n1701             del kwargs[\"max_length\"]\n1702         return name, path, args, kwargs\n1703 \n1704     def get_prep_value(self, value):\n1705         value = super().get_prep_value(value)\n1706         if value is None:\n1707             return None\n1708         return str(value)\n1709 \n1710     def formfield(self, **kwargs):\n1711         return super().formfield(**{\n1712             'path': self.path,\n1713             'match': self.match,\n1714             'recursive': self.recursive,\n1715             'form_class': forms.FilePathField,\n1716             'allow_files': self.allow_files,\n1717             'allow_folders': self.allow_folders,\n1718             **kwargs,\n1719         })\n1720 \n1721     def get_internal_type(self):\n1722         return \"FilePathField\"\n1723 \n1724 \n1725 class FloatField(Field):\n1726     empty_strings_allowed = False\n1727     default_error_messages = {\n1728         'invalid': _(\"'%(value)s' value must be a float.\"),\n1729     }\n1730     description = _(\"Floating point number\")\n1731 \n1732     def get_prep_value(self, value):\n1733         value = super().get_prep_value(value)\n1734         if value is None:\n1735             return None\n1736         return float(value)\n1737 \n1738     def get_internal_type(self):\n1739         return \"FloatField\"\n1740 \n1741     def to_python(self, value):\n1742         if value is None:\n1743             return value\n1744         try:\n1745             return float(value)\n1746         except (TypeError, ValueError):\n1747             raise exceptions.ValidationError(\n1748                 self.error_messages['invalid'],\n1749                 code='invalid',\n1750                 params={'value': value},\n1751             )\n1752 \n1753     def formfield(self, **kwargs):\n1754         return super().formfield(**{\n1755             'form_class': forms.FloatField,\n1756             **kwargs,\n1757         })\n1758 \n1759 \n1760 class IntegerField(Field):\n1761     empty_strings_allowed = False\n1762     default_error_messages = {\n1763         'invalid': _(\"'%(value)s' value must be an integer.\"),\n1764     }\n1765     description = _(\"Integer\")\n1766 \n1767     def check(self, **kwargs):\n1768         return [\n1769             *super().check(**kwargs),\n1770             *self._check_max_length_warning(),\n1771         ]\n1772 \n1773     def _check_max_length_warning(self):\n1774         if self.max_length is not None:\n1775             return [\n1776                 checks.Warning(\n1777                     \"'max_length' is ignored when used with %s.\" % self.__class__.__name__,\n1778                     hint=\"Remove 'max_length' from field\",\n1779                     obj=self,\n1780                     id='fields.W122',\n1781                 )\n1782             ]\n1783         return []\n1784 \n1785     @cached_property\n1786     def validators(self):\n1787         # These validators can't be added at field initialization time since\n1788         # they're based on values retrieved from `connection`.\n1789         validators_ = super().validators\n1790         internal_type = self.get_internal_type()\n1791         min_value, max_value = connection.ops.integer_field_range(internal_type)\n1792         if min_value is not None and not any(\n1793             (\n1794                 isinstance(validator, validators.MinValueValidator) and (\n1795                     validator.limit_value()\n1796                     if callable(validator.limit_value)\n1797                     else validator.limit_value\n1798                 ) >= min_value\n1799             ) for validator in validators_\n1800         ):\n1801             validators_.append(validators.MinValueValidator(min_value))\n1802         if max_value is not None and not any(\n1803             (\n1804                 isinstance(validator, validators.MaxValueValidator) and (\n1805                     validator.limit_value()\n1806                     if callable(validator.limit_value)\n1807                     else validator.limit_value\n1808                 ) <= max_value\n1809             ) for validator in validators_\n1810         ):\n1811             validators_.append(validators.MaxValueValidator(max_value))\n1812         return validators_\n1813 \n1814     def get_prep_value(self, value):\n1815         value = super().get_prep_value(value)\n1816         if value is None:\n1817             return None\n1818         return int(value)\n1819 \n1820     def get_internal_type(self):\n1821         return \"IntegerField\"\n1822 \n1823     def to_python(self, value):\n1824         if value is None:\n1825             return value\n1826         try:\n1827             return int(value)\n1828         except (TypeError, ValueError):\n1829             raise exceptions.ValidationError(\n1830                 self.error_messages['invalid'],\n1831                 code='invalid',\n1832                 params={'value': value},\n1833             )\n1834 \n1835     def formfield(self, **kwargs):\n1836         return super().formfield(**{\n1837             'form_class': forms.IntegerField,\n1838             **kwargs,\n1839         })\n1840 \n1841 \n1842 class BigIntegerField(IntegerField):\n1843     description = _(\"Big (8 byte) integer\")\n1844     MAX_BIGINT = 9223372036854775807\n1845 \n1846     def get_internal_type(self):\n1847         return \"BigIntegerField\"\n1848 \n1849     def formfield(self, **kwargs):\n1850         return super().formfield(**{\n1851             'min_value': -BigIntegerField.MAX_BIGINT - 1,\n1852             'max_value': BigIntegerField.MAX_BIGINT,\n1853             **kwargs,\n1854         })\n1855 \n1856 \n1857 class IPAddressField(Field):\n1858     empty_strings_allowed = False\n1859     description = _(\"IPv4 address\")\n1860     system_check_removed_details = {\n1861         'msg': (\n1862             'IPAddressField has been removed except for support in '\n1863             'historical migrations.'\n1864         ),\n1865         'hint': 'Use GenericIPAddressField instead.',\n1866         'id': 'fields.E900',\n1867     }\n1868 \n1869     def __init__(self, *args, **kwargs):\n1870         kwargs['max_length'] = 15\n1871         super().__init__(*args, **kwargs)\n1872 \n1873     def deconstruct(self):\n1874         name, path, args, kwargs = super().deconstruct()\n1875         del kwargs['max_length']\n1876         return name, path, args, kwargs\n1877 \n1878     def get_prep_value(self, value):\n1879         value = super().get_prep_value(value)\n1880         if value is None:\n1881             return None\n1882         return str(value)\n1883 \n1884     def get_internal_type(self):\n1885         return \"IPAddressField\"\n1886 \n1887 \n1888 class GenericIPAddressField(Field):\n1889     empty_strings_allowed = False\n1890     description = _(\"IP address\")\n1891     default_error_messages = {}\n1892 \n1893     def __init__(self, verbose_name=None, name=None, protocol='both',\n1894                  unpack_ipv4=False, *args, **kwargs):\n1895         self.unpack_ipv4 = unpack_ipv4\n1896         self.protocol = protocol\n1897         self.default_validators, invalid_error_message = \\\n1898             validators.ip_address_validators(protocol, unpack_ipv4)\n1899         self.default_error_messages['invalid'] = invalid_error_message\n1900         kwargs['max_length'] = 39\n1901         super().__init__(verbose_name, name, *args, **kwargs)\n1902 \n1903     def check(self, **kwargs):\n1904         return [\n1905             *super().check(**kwargs),\n1906             *self._check_blank_and_null_values(**kwargs),\n1907         ]\n1908 \n1909     def _check_blank_and_null_values(self, **kwargs):\n1910         if not getattr(self, 'null', False) and getattr(self, 'blank', False):\n1911             return [\n1912                 checks.Error(\n1913                     'GenericIPAddressFields cannot have blank=True if null=False, '\n1914                     'as blank values are stored as nulls.',\n1915                     obj=self,\n1916                     id='fields.E150',\n1917                 )\n1918             ]\n1919         return []\n1920 \n1921     def deconstruct(self):\n1922         name, path, args, kwargs = super().deconstruct()\n1923         if self.unpack_ipv4 is not False:\n1924             kwargs['unpack_ipv4'] = self.unpack_ipv4\n1925         if self.protocol != \"both\":\n1926             kwargs['protocol'] = self.protocol\n1927         if kwargs.get(\"max_length\") == 39:\n1928             del kwargs['max_length']\n1929         return name, path, args, kwargs\n1930 \n1931     def get_internal_type(self):\n1932         return \"GenericIPAddressField\"\n1933 \n1934     def to_python(self, value):\n1935         if value is None:\n1936             return None\n1937         if not isinstance(value, str):\n1938             value = str(value)\n1939         value = value.strip()\n1940         if ':' in value:\n1941             return clean_ipv6_address(value, self.unpack_ipv4, self.error_messages['invalid'])\n1942         return value\n1943 \n1944     def get_db_prep_value(self, value, connection, prepared=False):\n1945         if not prepared:\n1946             value = self.get_prep_value(value)\n1947         return connection.ops.adapt_ipaddressfield_value(value)\n1948 \n1949     def get_prep_value(self, value):\n1950         value = super().get_prep_value(value)\n1951         if value is None:\n1952             return None\n1953         if value and ':' in value:\n1954             try:\n1955                 return clean_ipv6_address(value, self.unpack_ipv4)\n1956             except exceptions.ValidationError:\n1957                 pass\n1958         return str(value)\n1959 \n1960     def formfield(self, **kwargs):\n1961         return super().formfield(**{\n1962             'protocol': self.protocol,\n1963             'form_class': forms.GenericIPAddressField,\n1964             **kwargs,\n1965         })\n1966 \n1967 \n1968 class NullBooleanField(BooleanField):\n1969     default_error_messages = {\n1970         'invalid': _(\"'%(value)s' value must be either None, True or False.\"),\n1971         'invalid_nullable': _(\"'%(value)s' value must be either None, True or False.\"),\n1972     }\n1973     description = _(\"Boolean (Either True, False or None)\")\n1974 \n1975     def __init__(self, *args, **kwargs):\n1976         kwargs['null'] = True\n1977         kwargs['blank'] = True\n1978         super().__init__(*args, **kwargs)\n1979 \n1980     def deconstruct(self):\n1981         name, path, args, kwargs = super().deconstruct()\n1982         del kwargs['null']\n1983         del kwargs['blank']\n1984         return name, path, args, kwargs\n1985 \n1986     def get_internal_type(self):\n1987         return \"NullBooleanField\"\n1988 \n1989 \n1990 class PositiveIntegerRelDbTypeMixin:\n1991 \n1992     def rel_db_type(self, connection):\n1993         \"\"\"\n1994         Return the data type that a related field pointing to this field should\n1995         use. In most cases, a foreign key pointing to a positive integer\n1996         primary key will have an integer column data type but some databases\n1997         (e.g. MySQL) have an unsigned integer type. In that case\n1998         (related_fields_match_type=True), the primary key should return its\n1999         db_type.\n2000         \"\"\"\n2001         if connection.features.related_fields_match_type:\n2002             return self.db_type(connection)\n2003         else:\n2004             return IntegerField().db_type(connection=connection)\n2005 \n2006 \n2007 class PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n2008     description = _(\"Positive integer\")\n2009 \n2010     def get_internal_type(self):\n2011         return \"PositiveIntegerField\"\n2012 \n2013     def formfield(self, **kwargs):\n2014         return super().formfield(**{\n2015             'min_value': 0,\n2016             **kwargs,\n2017         })\n2018 \n2019 \n2020 class PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField):\n2021     description = _(\"Positive small integer\")\n2022 \n2023     def get_internal_type(self):\n2024         return \"PositiveSmallIntegerField\"\n2025 \n2026     def formfield(self, **kwargs):\n2027         return super().formfield(**{\n2028             'min_value': 0,\n2029             **kwargs,\n2030         })\n2031 \n2032 \n2033 class SlugField(CharField):\n2034     default_validators = [validators.validate_slug]\n2035     description = _(\"Slug (up to %(max_length)s)\")\n2036 \n2037     def __init__(self, *args, max_length=50, db_index=True, allow_unicode=False, **kwargs):\n2038         self.allow_unicode = allow_unicode\n2039         if self.allow_unicode:\n2040             self.default_validators = [validators.validate_unicode_slug]\n2041         super().__init__(*args, max_length=max_length, db_index=db_index, **kwargs)\n2042 \n2043     def deconstruct(self):\n2044         name, path, args, kwargs = super().deconstruct()\n2045         if kwargs.get(\"max_length\") == 50:\n2046             del kwargs['max_length']\n2047         if self.db_index is False:\n2048             kwargs['db_index'] = False\n2049         else:\n2050             del kwargs['db_index']\n2051         if self.allow_unicode is not False:\n2052             kwargs['allow_unicode'] = self.allow_unicode\n2053         return name, path, args, kwargs\n2054 \n2055     def get_internal_type(self):\n2056         return \"SlugField\"\n2057 \n2058     def formfield(self, **kwargs):\n2059         return super().formfield(**{\n2060             'form_class': forms.SlugField,\n2061             'allow_unicode': self.allow_unicode,\n2062             **kwargs,\n2063         })\n2064 \n2065 \n2066 class SmallIntegerField(IntegerField):\n2067     description = _(\"Small integer\")\n2068 \n2069     def get_internal_type(self):\n2070         return \"SmallIntegerField\"\n2071 \n2072 \n2073 class TextField(Field):\n2074     description = _(\"Text\")\n2075 \n2076     def get_internal_type(self):\n2077         return \"TextField\"\n2078 \n2079     def to_python(self, value):\n2080         if isinstance(value, str) or value is None:\n2081             return value\n2082         return str(value)\n2083 \n2084     def get_prep_value(self, value):\n2085         value = super().get_prep_value(value)\n2086         return self.to_python(value)\n2087 \n2088     def formfield(self, **kwargs):\n2089         # Passing max_length to forms.CharField means that the value's length\n2090         # will be validated twice. This is considered acceptable since we want\n2091         # the value in the form field (to pass into widget for example).\n2092         return super().formfield(**{\n2093             'max_length': self.max_length,\n2094             **({} if self.choices is not None else {'widget': forms.Textarea}),\n2095             **kwargs,\n2096         })\n2097 \n2098 \n2099 class TimeField(DateTimeCheckMixin, Field):\n2100     empty_strings_allowed = False\n2101     default_error_messages = {\n2102         'invalid': _(\"'%(value)s' value has an invalid format. It must be in \"\n2103                      \"HH:MM[:ss[.uuuuuu]] format.\"),\n2104         'invalid_time': _(\"'%(value)s' value has the correct format \"\n2105                           \"(HH:MM[:ss[.uuuuuu]]) but it is an invalid time.\"),\n2106     }\n2107     description = _(\"Time\")\n2108 \n2109     def __init__(self, verbose_name=None, name=None, auto_now=False,\n2110                  auto_now_add=False, **kwargs):\n2111         self.auto_now, self.auto_now_add = auto_now, auto_now_add\n2112         if auto_now or auto_now_add:\n2113             kwargs['editable'] = False\n2114             kwargs['blank'] = True\n2115         super().__init__(verbose_name, name, **kwargs)\n2116 \n2117     def _check_fix_default_value(self):\n2118         \"\"\"\n2119         Warn that using an actual date or datetime value is probably wrong;\n2120         it's only evaluated on server startup.\n2121         \"\"\"\n2122         if not self.has_default():\n2123             return []\n2124 \n2125         now = timezone.now()\n2126         if not timezone.is_naive(now):\n2127             now = timezone.make_naive(now, timezone.utc)\n2128         value = self.default\n2129         if isinstance(value, datetime.datetime):\n2130             second_offset = datetime.timedelta(seconds=10)\n2131             lower = now - second_offset\n2132             upper = now + second_offset\n2133             if timezone.is_aware(value):\n2134                 value = timezone.make_naive(value, timezone.utc)\n2135         elif isinstance(value, datetime.time):\n2136             second_offset = datetime.timedelta(seconds=10)\n2137             lower = now - second_offset\n2138             upper = now + second_offset\n2139             value = datetime.datetime.combine(now.date(), value)\n2140             if timezone.is_aware(value):\n2141                 value = timezone.make_naive(value, timezone.utc).time()\n2142         else:\n2143             # No explicit time / datetime value -- no checks necessary\n2144             return []\n2145         if lower <= value <= upper:\n2146             return [\n2147                 checks.Warning(\n2148                     'Fixed default value provided.',\n2149                     hint='It seems you set a fixed date / time / datetime '\n2150                          'value as default for this field. This may not be '\n2151                          'what you want. If you want to have the current date '\n2152                          'as default, use `django.utils.timezone.now`',\n2153                     obj=self,\n2154                     id='fields.W161',\n2155                 )\n2156             ]\n2157 \n2158         return []\n2159 \n2160     def deconstruct(self):\n2161         name, path, args, kwargs = super().deconstruct()\n2162         if self.auto_now is not False:\n2163             kwargs[\"auto_now\"] = self.auto_now\n2164         if self.auto_now_add is not False:\n2165             kwargs[\"auto_now_add\"] = self.auto_now_add\n2166         if self.auto_now or self.auto_now_add:\n2167             del kwargs['blank']\n2168             del kwargs['editable']\n2169         return name, path, args, kwargs\n2170 \n2171     def get_internal_type(self):\n2172         return \"TimeField\"\n2173 \n2174     def to_python(self, value):\n2175         if value is None:\n2176             return None\n2177         if isinstance(value, datetime.time):\n2178             return value\n2179         if isinstance(value, datetime.datetime):\n2180             # Not usually a good idea to pass in a datetime here (it loses\n2181             # information), but this can be a side-effect of interacting with a\n2182             # database backend (e.g. Oracle), so we'll be accommodating.\n2183             return value.time()\n2184 \n2185         try:\n2186             parsed = parse_time(value)\n2187             if parsed is not None:\n2188                 return parsed\n2189         except ValueError:\n2190             raise exceptions.ValidationError(\n2191                 self.error_messages['invalid_time'],\n2192                 code='invalid_time',\n2193                 params={'value': value},\n2194             )\n2195 \n2196         raise exceptions.ValidationError(\n2197             self.error_messages['invalid'],\n2198             code='invalid',\n2199             params={'value': value},\n2200         )\n2201 \n2202     def pre_save(self, model_instance, add):\n2203         if self.auto_now or (self.auto_now_add and add):\n2204             value = datetime.datetime.now().time()\n2205             setattr(model_instance, self.attname, value)\n2206             return value\n2207         else:\n2208             return super().pre_save(model_instance, add)\n2209 \n2210     def get_prep_value(self, value):\n2211         value = super().get_prep_value(value)\n2212         return self.to_python(value)\n2213 \n2214     def get_db_prep_value(self, value, connection, prepared=False):\n2215         # Casts times into the format expected by the backend\n2216         if not prepared:\n2217             value = self.get_prep_value(value)\n2218         return connection.ops.adapt_timefield_value(value)\n2219 \n2220     def value_to_string(self, obj):\n2221         val = self.value_from_object(obj)\n2222         return '' if val is None else val.isoformat()\n2223 \n2224     def formfield(self, **kwargs):\n2225         return super().formfield(**{\n2226             'form_class': forms.TimeField,\n2227             **kwargs,\n2228         })\n2229 \n2230 \n2231 class URLField(CharField):\n2232     default_validators = [validators.URLValidator()]\n2233     description = _(\"URL\")\n2234 \n2235     def __init__(self, verbose_name=None, name=None, **kwargs):\n2236         kwargs.setdefault('max_length', 200)\n2237         super().__init__(verbose_name, name, **kwargs)\n2238 \n2239     def deconstruct(self):\n2240         name, path, args, kwargs = super().deconstruct()\n2241         if kwargs.get(\"max_length\") == 200:\n2242             del kwargs['max_length']\n2243         return name, path, args, kwargs\n2244 \n2245     def formfield(self, **kwargs):\n2246         # As with CharField, this will cause URL validation to be performed\n2247         # twice.\n2248         return super().formfield(**{\n2249             'form_class': forms.URLField,\n2250             **kwargs,\n2251         })\n2252 \n2253 \n2254 class BinaryField(Field):\n2255     description = _(\"Raw binary data\")\n2256     empty_values = [None, b'']\n2257 \n2258     def __init__(self, *args, **kwargs):\n2259         kwargs.setdefault('editable', False)\n2260         super().__init__(*args, **kwargs)\n2261         if self.max_length is not None:\n2262             self.validators.append(validators.MaxLengthValidator(self.max_length))\n2263 \n2264     def check(self, **kwargs):\n2265         return [*super().check(**kwargs), *self._check_str_default_value()]\n2266 \n2267     def _check_str_default_value(self):\n2268         if self.has_default() and isinstance(self.default, str):\n2269             return [\n2270                 checks.Error(\n2271                     \"BinaryField's default cannot be a string. Use bytes \"\n2272                     \"content instead.\",\n2273                     obj=self,\n2274                     id='fields.E170',\n2275                 )\n2276             ]\n2277         return []\n2278 \n2279     def deconstruct(self):\n2280         name, path, args, kwargs = super().deconstruct()\n2281         if self.editable:\n2282             kwargs['editable'] = True\n2283         else:\n2284             del kwargs['editable']\n2285         return name, path, args, kwargs\n2286 \n2287     def get_internal_type(self):\n2288         return \"BinaryField\"\n2289 \n2290     def get_placeholder(self, value, compiler, connection):\n2291         return connection.ops.binary_placeholder_sql(value)\n2292 \n2293     def get_default(self):\n2294         if self.has_default() and not callable(self.default):\n2295             return self.default\n2296         default = super().get_default()\n2297         if default == '':\n2298             return b''\n2299         return default\n2300 \n2301     def get_db_prep_value(self, value, connection, prepared=False):\n2302         value = super().get_db_prep_value(value, connection, prepared)\n2303         if value is not None:\n2304             return connection.Database.Binary(value)\n2305         return value\n2306 \n2307     def value_to_string(self, obj):\n2308         \"\"\"Binary data is serialized as base64\"\"\"\n2309         return b64encode(self.value_from_object(obj)).decode('ascii')\n2310 \n2311     def to_python(self, value):\n2312         # If it's a string, it should be base64-encoded data\n2313         if isinstance(value, str):\n2314             return memoryview(b64decode(value.encode('ascii')))\n2315         return value\n2316 \n2317 \n2318 class UUIDField(Field):\n2319     default_error_messages = {\n2320         'invalid': _(\"'%(value)s' is not a valid UUID.\"),\n2321     }\n2322     description = _('Universally unique identifier')\n2323     empty_strings_allowed = False\n2324 \n2325     def __init__(self, verbose_name=None, **kwargs):\n2326         kwargs['max_length'] = 32\n2327         super().__init__(verbose_name, **kwargs)\n2328 \n2329     def deconstruct(self):\n2330         name, path, args, kwargs = super().deconstruct()\n2331         del kwargs['max_length']\n2332         return name, path, args, kwargs\n2333 \n2334     def get_internal_type(self):\n2335         return \"UUIDField\"\n2336 \n2337     def get_prep_value(self, value):\n2338         value = super().get_prep_value(value)\n2339         return self.to_python(value)\n2340 \n2341     def get_db_prep_value(self, value, connection, prepared=False):\n2342         if value is None:\n2343             return None\n2344         if not isinstance(value, uuid.UUID):\n2345             value = self.to_python(value)\n2346 \n2347         if connection.features.has_native_uuid_field:\n2348             return value\n2349         return value.hex\n2350 \n2351     def to_python(self, value):\n2352         if value is not None and not isinstance(value, uuid.UUID):\n2353             input_form = 'int' if isinstance(value, int) else 'hex'\n2354             try:\n2355                 return uuid.UUID(**{input_form: value})\n2356             except (AttributeError, ValueError):\n2357                 raise exceptions.ValidationError(\n2358                     self.error_messages['invalid'],\n2359                     code='invalid',\n2360                     params={'value': value},\n2361                 )\n2362         return value\n2363 \n2364     def formfield(self, **kwargs):\n2365         return super().formfield(**{\n2366             'form_class': forms.UUIDField,\n2367             **kwargs,\n2368         })\n2369 \n[end of django/db/models/fields/__init__.py]\n</code>\nI need you to solve this issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the following format.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\n"
}
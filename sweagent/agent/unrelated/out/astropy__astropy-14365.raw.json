{
  "instance_id": "astropy__astropy-14365",
  "variant": "oracle",
  "split": "test",
  "meta": {
    "instance_id": "astropy__astropy-14365",
    "repo": "astropy/astropy",
    "base_commit": "7269fa3e33e8d02485a647da91a5a2a60a06af61",
    "patch": "<patch>\ndiff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -68,7 +68,7 @@ def _line_type(line, delimiter=None):\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"\n@@ -306,7 +306,7 @@ def _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n \n             values = []\n             for v in line.split(delimiter):\n-                if v == \"NO\":\n+                if v.upper() == \"NO\":\n                     values.append(np.ma.masked)\n                 else:\n                     # Understand if number is int or float\n\n</patch>",
    "test_patch": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -43,7 +43,18 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n \n-def test_roundtrip(tmp_path):\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n+\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_roundtrip(tmp_path, lowercase):\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n     ! Columns are as labelled\n@@ -70,6 +81,8 @@ def test_roundtrip(tmp_path):\n     53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n     NO 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n     \"\"\"\n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n \n     path = str(tmp_path / \"test.qdp\")\n     path2 = str(tmp_path / \"test2.qdp\")\n",
    "created_at": "2023-02-06T19:20:34Z",
    "version": "5.1",
    "FAIL_TO_PASS": "[\"astropy/io/ascii/tests/test_qdp.py::test_roundtrip[True]\"]",
    "PASS_TO_PASS": "[\"astropy/io/ascii/tests/test_qdp.py::test_get_tables_from_qdp_file\", \"astropy/io/ascii/tests/test_qdp.py::test_roundtrip[False]\", \"astropy/io/ascii/tests/test_qdp.py::test_read_example\", \"astropy/io/ascii/tests/test_qdp.py::test_roundtrip_example\", \"astropy/io/ascii/tests/test_qdp.py::test_roundtrip_example_comma\", \"astropy/io/ascii/tests/test_qdp.py::test_read_write_simple\", \"astropy/io/ascii/tests/test_qdp.py::test_read_write_simple_specify_name\", \"astropy/io/ascii/tests/test_qdp.py::test_get_lines_from_qdp\"]"
  },
  "text": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nascii.qdp Table format assumes QDP commands are upper case\n### Description\n\nascii.qdp assumes that commands in a QDP file are upper case, for example, for errors they must be \"READ SERR 1 2\" whereas QDP itself is not case sensitive and case use \"read serr 1 2\". \r\n\r\nAs many QDP files are created by hand, the expectation that all commands be all-caps should be removed.\n\n### Expected behavior\n\nThe following qdp file should read into a `Table` with errors, rather than crashing.\r\n```\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n```\n\n### How to Reproduce\n\nCreate a QDP file:\r\n```\r\n> cat > test.qdp\r\nread serr 1 2 \r\n1 0.5 1 0.5\r\n<EOF>\r\n\r\n > python\r\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from astropy.table import Table\r\n>>> Table.read('test.qdp',format='ascii.qdp')\r\nWARNING: table_id not specified. Reading the first available table [astropy.io.ascii.qdp]\r\nTraceback (most recent call last):\r\n...\r\n    raise ValueError(f'Unrecognized QDP line: {line}')\r\nValueError: Unrecognized QDP line: read serr 1 2\r\n```\r\n\r\nRunning \"qdp test.qdp\" works just fine.\r\n\n\n### Versions\n\nPython 3.10.9 (main, Dec  7 2022, 02:03:23) [Clang 13.0.0 (clang-1300.0.29.30)]\r\nastropy 5.1\r\nNumpy 1.24.1\r\npyerfa 2.0.0.1\r\nScipy 1.10.0\r\nMatplotlib 3.6.3\r\n\n\n</issue>\n<code>\n[start of README.rst]\n1 =======\n2 Astropy\n3 =======\n4 \n5 .. container::\n6 \n7     |Actions Status| |CircleCI Status| |Coverage Status| |PyPI Status| |Documentation Status| |Pre-Commit| |isort Status| |black| |Zenodo|\n8 \n9 The Astropy Project (http://astropy.org/) is a community effort to develop a\n10 single core package for Astronomy in Python and foster interoperability between\n11 Python astronomy packages. This repository contains the core package which is\n12 intended to contain much of the core functionality and some common tools needed\n13 for performing astronomy and astrophysics with Python.\n14 \n15 Releases are `registered on PyPI <https://pypi.org/project/astropy>`_,\n16 and development is occurring at the\n17 `project's GitHub page <http://github.com/astropy/astropy>`_.\n18 \n19 For installation instructions, see the `online documentation <https://docs.astropy.org/>`_\n20 or  `docs/install.rst <docs/install.rst>`_ in this source distribution.\n21 \n22 Contributing Code, Documentation, or Feedback\n23 ---------------------------------------------\n24 \n25 The Astropy Project is made both by and for its users, so we welcome and\n26 encourage contributions of many kinds. Our goal is to keep this a positive,\n27 inclusive, successful, and growing community by abiding with the\n28 `Astropy Community Code of Conduct <http://www.astropy.org/about.html#codeofconduct>`_.\n29 \n30 More detailed information on contributing to the project or submitting feedback\n31 can be found on the `contributions <http://www.astropy.org/contribute.html>`_\n32 page. A `summary of contribution guidelines <CONTRIBUTING.md>`_ can also be\n33 used as a quick reference when you are ready to start writing or validating\n34 code for submission.\n35 \n36 Getting started with GitHub Codespaces\n37 --------------------------------------\n38 \n39 Codespaces is a cloud development environment supported by GitHub. None of the Astropy build machinery depends on it, but it is a convenient way to quickly get started doing development on Astropy.\n40 \n41 To get started, create a codespace for this repository by clicking this ðŸ‘‡\n42 \n43 |Codespaces|\n44 \n45 A codespace will open in a web-based version of Visual Studio Code. The `dev container <.devcontainer/devcontainer.json>`_ is fully configured with software needed for this project. Feel free to take a look at `GitHub Codespaces Support <https://support.github.com/features/codespaces>`_ page for help.\n46 \n47 **Note**: Dev containers is an open spec which is supported by `GitHub Codespaces <https://github.com/codespaces>`_ and `other tools <https://containers.dev/supporting>`_.\n48 \n49 Supporting the Project\n50 ----------------------\n51 \n52 |NumFOCUS| |Donate|\n53 \n54 The Astropy Project is sponsored by NumFOCUS, a 501(c)(3) nonprofit in the\n55 United States. You can donate to the project by using the link above, and this\n56 donation will support our mission to promote sustainable, high-level code base\n57 for the astronomy community, open code development, educational materials, and\n58 reproducible scientific research.\n59 \n60 License\n61 -------\n62 \n63 Astropy is licensed under a 3-clause BSD style license - see the\n64 `LICENSE.rst <LICENSE.rst>`_ file.\n65 \n66 .. |Actions Status| image:: https://github.com/astropy/astropy/workflows/CI/badge.svg\n67     :target: https://github.com/astropy/astropy/actions\n68     :alt: Astropy's GitHub Actions CI Status\n69 \n70 .. |CircleCI Status| image::  https://img.shields.io/circleci/build/github/astropy/astropy/main?logo=circleci&label=CircleCI\n71     :target: https://circleci.com/gh/astropy/astropy\n72     :alt: Astropy's CircleCI Status\n73 \n74 .. |Coverage Status| image:: https://codecov.io/gh/astropy/astropy/branch/main/graph/badge.svg\n75     :target: https://codecov.io/gh/astropy/astropy\n76     :alt: Astropy's Coverage Status\n77 \n78 .. |PyPI Status| image:: https://img.shields.io/pypi/v/astropy.svg\n79     :target: https://pypi.org/project/astropy\n80     :alt: Astropy's PyPI Status\n81 \n82 .. |Zenodo| image:: https://zenodo.org/badge/DOI/10.5281/zenodo.4670728.svg\n83    :target: https://doi.org/10.5281/zenodo.4670728\n84    :alt: Zenodo DOI\n85 \n86 .. |Documentation Status| image:: https://img.shields.io/readthedocs/astropy/latest.svg?logo=read%20the%20docs&logoColor=white&label=Docs&version=stable\n87     :target: https://docs.astropy.org/en/stable/?badge=stable\n88     :alt: Documentation Status\n89 \n90 .. |Pre-Commit| image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white\n91    :target: https://github.com/pre-commit/pre-commit\n92    :alt: pre-commit\n93 \n94 .. |isort Status| image:: https://img.shields.io/badge/%20imports-isort-%231674b1?style=flat&labelColor=ef8336\n95     :target: https://pycqa.github.io/isort/\n96     :alt: isort Status\n97 \n98 .. |black| image:: https://img.shields.io/badge/code%20style-black-000000.svg\n99     :target: https://github.com/psf/black\n100 \n101 .. |NumFOCUS| image:: https://img.shields.io/badge/powered%20by-NumFOCUS-orange.svg?style=flat&colorA=E1523D&colorB=007D8A\n102     :target: http://numfocus.org\n103     :alt: Powered by NumFOCUS\n104 \n105 .. |Donate| image:: https://img.shields.io/badge/Donate-to%20Astropy-brightgreen.svg\n106     :target: https://numfocus.salsalabs.org/donate-to-astropy/index.html\n107 \n108 .. |Codespaces| image:: https://github.com/codespaces/badge.svg\n109     :target: https://github.com/codespaces/new?hide_repo_select=true&ref=main&repo=2081289\n110     :alt: Open in GitHub Codespaces\n111 \n112 \n113 If you locally cloned this repo before 7 Apr 2021\n114 -------------------------------------------------\n115 \n116 The primary branch for this repo has been transitioned from ``master`` to\n117 ``main``.  If you have a local clone of this repository and want to keep your\n118 local branch in sync with this repo, you'll need to do the following in your\n119 local clone from your terminal::\n120 \n121    git fetch --all --prune\n122    # you can stop here if you don't use your local \"master\"/\"main\" branch\n123    git branch -m master main\n124    git branch -u origin/main main\n125 \n126 If you are using a GUI to manage your repos you'll have to find the equivalent\n127 commands as it's different for different programs. Alternatively, you can just\n128 delete your local clone and re-clone!\n129 \n[end of README.rst]\n[start of astropy/io/ascii/qdp.py]\n1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \"\"\"\n3 This package contains functions for reading and writing QDP tables that are\n4 not meant to be used directly, but instead are available as readers/writers in\n5 `astropy.table`. See :ref:`astropy:table_io` for more details.\n6 \"\"\"\n7 import copy\n8 import re\n9 import warnings\n10 from collections.abc import Iterable\n11 \n12 import numpy as np\n13 \n14 from astropy.table import Table\n15 from astropy.utils.exceptions import AstropyUserWarning\n16 \n17 from . import basic, core\n18 \n19 \n20 def _line_type(line, delimiter=None):\n21     \"\"\"Interpret a QDP file line.\n22 \n23     Parameters\n24     ----------\n25     line : str\n26         a single line of the file\n27 \n28     Returns\n29     -------\n30     type : str\n31         Line type: \"comment\", \"command\", or \"data\"\n32 \n33     Examples\n34     --------\n35     >>> _line_type(\"READ SERR 3\")\n36     'command'\n37     >>> _line_type(\" \\\\n    !some gibberish\")\n38     'comment'\n39     >>> _line_type(\"   \")\n40     'comment'\n41     >>> _line_type(\" 21345.45\")\n42     'data,1'\n43     >>> _line_type(\" 21345.45 1.53e-3 1e-3 .04 NO nan\")\n44     'data,6'\n45     >>> _line_type(\" 21345.45,1.53e-3,1e-3,.04,NO,nan\", delimiter=',')\n46     'data,6'\n47     >>> _line_type(\" 21345.45 ! a comment to disturb\")\n48     'data,1'\n49     >>> _line_type(\"NO NO NO NO NO\")\n50     'new'\n51     >>> _line_type(\"NO,NO,NO,NO,NO\", delimiter=',')\n52     'new'\n53     >>> _line_type(\"N O N NOON OON O\")\n54     Traceback (most recent call last):\n55         ...\n56     ValueError: Unrecognized QDP line...\n57     >>> _line_type(\" some non-comment gibberish\")\n58     Traceback (most recent call last):\n59         ...\n60     ValueError: Unrecognized QDP line...\n61     \"\"\"\n62     _decimal_re = r\"[+-]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][+-]?\\d+)?\"\n63     _command_re = r\"READ [TS]ERR(\\s+[0-9]+)+\"\n64 \n65     sep = delimiter\n66     if delimiter is None:\n67         sep = r\"\\s+\"\n68     _new_re = rf\"NO({sep}NO)+\"\n69     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n70     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n71     _line_type_re = re.compile(_type_re)\n72     line = line.strip()\n73     if not line:\n74         return \"comment\"\n75     match = _line_type_re.match(line)\n76 \n77     if match is None:\n78         raise ValueError(f\"Unrecognized QDP line: {line}\")\n79     for type_, val in match.groupdict().items():\n80         if val is None:\n81             continue\n82         if type_ == \"data\":\n83             return f\"data,{len(val.split(sep=delimiter))}\"\n84         else:\n85             return type_\n86 \n87 \n88 def _get_type_from_list_of_lines(lines, delimiter=None):\n89     \"\"\"Read through the list of QDP file lines and label each line by type.\n90 \n91     Parameters\n92     ----------\n93     lines : list\n94         List containing one file line in each entry\n95 \n96     Returns\n97     -------\n98     contents : list\n99         List containing the type for each line (see `line_type_and_data`)\n100     ncol : int\n101         The number of columns in the data lines. Must be the same throughout\n102         the file\n103 \n104     Examples\n105     --------\n106     >>> line0 = \"! A comment\"\n107     >>> line1 = \"543 12 456.0\"\n108     >>> lines = [line0, line1]\n109     >>> types, ncol = _get_type_from_list_of_lines(lines)\n110     >>> types[0]\n111     'comment'\n112     >>> types[1]\n113     'data,3'\n114     >>> ncol\n115     3\n116     >>> lines.append(\"23\")\n117     >>> _get_type_from_list_of_lines(lines)\n118     Traceback (most recent call last):\n119         ...\n120     ValueError: Inconsistent number of columns\n121     \"\"\"\n122     types = [_line_type(line, delimiter=delimiter) for line in lines]\n123     current_ncol = None\n124     for type_ in types:\n125         if type_.startswith(\"data,\"):\n126             ncol = int(type_[5:])\n127             if current_ncol is None:\n128                 current_ncol = ncol\n129             elif ncol != current_ncol:\n130                 raise ValueError(\"Inconsistent number of columns\")\n131 \n132     return types, current_ncol\n133 \n134 \n135 def _get_lines_from_file(qdp_file):\n136     if \"\\n\" in qdp_file:\n137         lines = qdp_file.split(\"\\n\")\n138     elif isinstance(qdp_file, str):\n139         with open(qdp_file) as fobj:\n140             lines = [line.strip() for line in fobj.readlines()]\n141     elif isinstance(qdp_file, Iterable):\n142         lines = qdp_file\n143     else:\n144         raise ValueError(\"invalid value of qdb_file\")\n145 \n146     return lines\n147 \n148 \n149 def _interpret_err_lines(err_specs, ncols, names=None):\n150     \"\"\"Give list of column names from the READ SERR and TERR commands.\n151 \n152     Parameters\n153     ----------\n154     err_specs : dict\n155         ``{'serr': [n0, n1, ...], 'terr': [n2, n3, ...]}``\n156         Error specifications for symmetric and two-sided errors\n157     ncols : int\n158         Number of data columns\n159 \n160     Other Parameters\n161     ----------------\n162     names : list of str\n163         Name of data columns (defaults to ['col1', 'col2', ...]), _not_\n164         including error columns.\n165 \n166     Returns\n167     -------\n168     colnames : list\n169         List containing the column names. Error columns will have the name\n170         of the main column plus ``_err`` for symmetric errors, and ``_perr``\n171         and ``_nerr`` for positive and negative errors respectively\n172 \n173     Examples\n174     --------\n175     >>> col_in = ['MJD', 'Rate']\n176     >>> cols = _interpret_err_lines(None, 2, names=col_in)\n177     >>> cols[0]\n178     'MJD'\n179     >>> err_specs = {'terr': [1], 'serr': [2]}\n180     >>> ncols = 5\n181     >>> cols = _interpret_err_lines(err_specs, ncols, names=col_in)\n182     >>> cols[0]\n183     'MJD'\n184     >>> cols[2]\n185     'MJD_nerr'\n186     >>> cols[4]\n187     'Rate_err'\n188     >>> _interpret_err_lines(err_specs, 6, names=col_in)\n189     Traceback (most recent call last):\n190         ...\n191     ValueError: Inconsistent number of input colnames\n192     \"\"\"\n193     colnames = [\"\" for i in range(ncols)]\n194     if err_specs is None:\n195         serr_cols = terr_cols = []\n196 \n197     else:\n198         # I don't want to empty the original one when using `pop` below\n199         err_specs = copy.deepcopy(err_specs)\n200 \n201         serr_cols = err_specs.pop(\"serr\", [])\n202         terr_cols = err_specs.pop(\"terr\", [])\n203 \n204     if names is not None:\n205         all_error_cols = len(serr_cols) + len(terr_cols) * 2\n206         if all_error_cols + len(names) != ncols:\n207             raise ValueError(\"Inconsistent number of input colnames\")\n208 \n209     shift = 0\n210     for i in range(ncols):\n211         col_num = i + 1 - shift\n212         if colnames[i] != \"\":\n213             continue\n214 \n215         colname_root = f\"col{col_num}\"\n216 \n217         if names is not None:\n218             colname_root = names[col_num - 1]\n219 \n220         colnames[i] = f\"{colname_root}\"\n221         if col_num in serr_cols:\n222             colnames[i + 1] = f\"{colname_root}_err\"\n223             shift += 1\n224             continue\n225 \n226         if col_num in terr_cols:\n227             colnames[i + 1] = f\"{colname_root}_perr\"\n228             colnames[i + 2] = f\"{colname_root}_nerr\"\n229             shift += 2\n230             continue\n231 \n232     assert not np.any([c == \"\" for c in colnames])\n233 \n234     return colnames\n235 \n236 \n237 def _get_tables_from_qdp_file(qdp_file, input_colnames=None, delimiter=None):\n238     \"\"\"Get all tables from a QDP file.\n239 \n240     Parameters\n241     ----------\n242     qdp_file : str\n243         Input QDP file name\n244 \n245     Other Parameters\n246     ----------------\n247     input_colnames : list of str\n248         Name of data columns (defaults to ['col1', 'col2', ...]), _not_\n249         including error columns.\n250     delimiter : str\n251         Delimiter for the values in the table.\n252 \n253     Returns\n254     -------\n255     list of `~astropy.table.Table`\n256         List containing all the tables present inside the QDP file\n257     \"\"\"\n258     lines = _get_lines_from_file(qdp_file)\n259     contents, ncol = _get_type_from_list_of_lines(lines, delimiter=delimiter)\n260 \n261     table_list = []\n262     err_specs = {}\n263     colnames = None\n264 \n265     comment_text = \"\"\n266     initial_comments = \"\"\n267     command_lines = \"\"\n268     current_rows = None\n269 \n270     for line, datatype in zip(lines, contents):\n271         line = line.strip().lstrip(\"!\")\n272         # Is this a comment?\n273         if datatype == \"comment\":\n274             comment_text += line + \"\\n\"\n275             continue\n276 \n277         if datatype == \"command\":\n278             # The first time I find commands, I save whatever comments into\n279             # The initial comments.\n280             if command_lines == \"\":\n281                 initial_comments = comment_text\n282                 comment_text = \"\"\n283 \n284             if err_specs != {}:\n285                 warnings.warn(\n286                     \"This file contains multiple command blocks. Please verify\",\n287                     AstropyUserWarning,\n288                 )\n289             command_lines += line + \"\\n\"\n290             continue\n291 \n292         if datatype.startswith(\"data\"):\n293             # The first time I find data, I define err_specs\n294             if err_specs == {} and command_lines != \"\":\n295                 for cline in command_lines.strip().split(\"\\n\"):\n296                     command = cline.strip().split()\n297                     # This should never happen, but just in case.\n298                     if len(command) < 3:\n299                         continue\n300                     err_specs[command[1].lower()] = [int(c) for c in command[2:]]\n301             if colnames is None:\n302                 colnames = _interpret_err_lines(err_specs, ncol, names=input_colnames)\n303 \n304             if current_rows is None:\n305                 current_rows = []\n306 \n307             values = []\n308             for v in line.split(delimiter):\n309                 if v == \"NO\":\n310                     values.append(np.ma.masked)\n311                 else:\n312                     # Understand if number is int or float\n313                     try:\n314                         values.append(int(v))\n315                     except ValueError:\n316                         values.append(float(v))\n317             current_rows.append(values)\n318             continue\n319 \n320         if datatype == \"new\":\n321             # Save table to table_list and reset\n322             if current_rows is not None:\n323                 new_table = Table(names=colnames, rows=current_rows)\n324                 new_table.meta[\"initial_comments\"] = initial_comments.strip().split(\n325                     \"\\n\"\n326                 )\n327                 new_table.meta[\"comments\"] = comment_text.strip().split(\"\\n\")\n328                 # Reset comments\n329                 comment_text = \"\"\n330                 table_list.append(new_table)\n331                 current_rows = None\n332             continue\n333 \n334     # At the very end, if there is still a table being written, let's save\n335     # it to the table_list\n336     if current_rows is not None:\n337         new_table = Table(names=colnames, rows=current_rows)\n338         new_table.meta[\"initial_comments\"] = initial_comments.strip().split(\"\\n\")\n339         new_table.meta[\"comments\"] = comment_text.strip().split(\"\\n\")\n340         table_list.append(new_table)\n341 \n342     return table_list\n343 \n344 \n345 def _understand_err_col(colnames):\n346     \"\"\"Get which column names are error columns.\n347 \n348     Examples\n349     --------\n350     >>> colnames = ['a', 'a_err', 'b', 'b_perr', 'b_nerr']\n351     >>> serr, terr = _understand_err_col(colnames)\n352     >>> np.allclose(serr, [1])\n353     True\n354     >>> np.allclose(terr, [2])\n355     True\n356     >>> serr, terr = _understand_err_col(['a', 'a_nerr'])\n357     Traceback (most recent call last):\n358     ...\n359     ValueError: Missing positive error...\n360     >>> serr, terr = _understand_err_col(['a', 'a_perr'])\n361     Traceback (most recent call last):\n362     ...\n363     ValueError: Missing negative error...\n364     \"\"\"\n365     shift = 0\n366     serr = []\n367     terr = []\n368 \n369     for i, col in enumerate(colnames):\n370         if col.endswith(\"_err\"):\n371             # The previous column, but they're numbered from 1!\n372             # Plus, take shift into account\n373             serr.append(i - shift)\n374             shift += 1\n375         elif col.endswith(\"_perr\"):\n376             terr.append(i - shift)\n377             if len(colnames) == i + 1 or not colnames[i + 1].endswith(\"_nerr\"):\n378                 raise ValueError(\"Missing negative error\")\n379             shift += 2\n380         elif col.endswith(\"_nerr\") and not colnames[i - 1].endswith(\"_perr\"):\n381             raise ValueError(\"Missing positive error\")\n382     return serr, terr\n383 \n384 \n385 def _read_table_qdp(qdp_file, names=None, table_id=None, delimiter=None):\n386     \"\"\"Read a table from a QDP file.\n387 \n388     Parameters\n389     ----------\n390     qdp_file : str\n391         Input QDP file name\n392 \n393     Other Parameters\n394     ----------------\n395     names : list of str\n396         Name of data columns (defaults to ['col1', 'col2', ...]), _not_\n397         including error columns.\n398 \n399     table_id : int, default 0\n400         Number of the table to be read from the QDP file. This is useful\n401         when multiple tables present in the file. By default, the first is read.\n402 \n403     delimiter : str\n404         Any delimiter accepted by the `sep` argument of str.split()\n405 \n406     Returns\n407     -------\n408     tables : list of `~astropy.table.Table`\n409         List containing all the tables present inside the QDP file\n410     \"\"\"\n411     if table_id is None:\n412         warnings.warn(\n413             \"table_id not specified. Reading the first available table\",\n414             AstropyUserWarning,\n415         )\n416         table_id = 0\n417 \n418     tables = _get_tables_from_qdp_file(\n419         qdp_file, input_colnames=names, delimiter=delimiter\n420     )\n421 \n422     return tables[table_id]\n423 \n424 \n425 def _write_table_qdp(table, filename=None, err_specs=None):\n426     \"\"\"Write a table to a QDP file.\n427 \n428     Parameters\n429     ----------\n430     table : :class:`~astropy.table.Table`\n431         Input table to be written\n432     filename : str\n433         Output QDP file name\n434 \n435     Other Parameters\n436     ----------------\n437     err_specs : dict\n438         Dictionary of the format {'serr': [1], 'terr': [2, 3]}, specifying\n439         which columns have symmetric and two-sided errors (see QDP format\n440         specification)\n441     \"\"\"\n442     import io\n443 \n444     fobj = io.StringIO()\n445 \n446     if \"initial_comments\" in table.meta and table.meta[\"initial_comments\"] != []:\n447         for line in table.meta[\"initial_comments\"]:\n448             line = line.strip()\n449             if not line.startswith(\"!\"):\n450                 line = \"!\" + line\n451             print(line, file=fobj)\n452 \n453     if err_specs is None:\n454         serr_cols, terr_cols = _understand_err_col(table.colnames)\n455     else:\n456         serr_cols = err_specs.pop(\"serr\", [])\n457         terr_cols = err_specs.pop(\"terr\", [])\n458     if serr_cols != []:\n459         col_string = \" \".join([str(val) for val in serr_cols])\n460         print(f\"READ SERR {col_string}\", file=fobj)\n461     if terr_cols != []:\n462         col_string = \" \".join([str(val) for val in terr_cols])\n463         print(f\"READ TERR {col_string}\", file=fobj)\n464 \n465     if \"comments\" in table.meta and table.meta[\"comments\"] != []:\n466         for line in table.meta[\"comments\"]:\n467             line = line.strip()\n468             if not line.startswith(\"!\"):\n469                 line = \"!\" + line\n470             print(line, file=fobj)\n471 \n472     colnames = table.colnames\n473     print(\"!\" + \" \".join(colnames), file=fobj)\n474     for row in table:\n475         values = []\n476         for val in row:\n477             if not np.ma.is_masked(val):\n478                 rep = str(val)\n479             else:\n480                 rep = \"NO\"\n481             values.append(rep)\n482         print(\" \".join(values), file=fobj)\n483 \n484     full_string = fobj.getvalue()\n485     fobj.close()\n486 \n487     if filename is not None:\n488         with open(filename, \"w\") as fobj:\n489             print(full_string, file=fobj)\n490 \n491     return full_string.split(\"\\n\")\n492 \n493 \n494 class QDPSplitter(core.DefaultSplitter):\n495     \"\"\"\n496     Split on space for QDP tables.\n497     \"\"\"\n498 \n499     delimiter = \" \"\n500 \n501 \n502 class QDPHeader(basic.CommentedHeaderHeader):\n503     \"\"\"\n504     Header that uses the :class:`astropy.io.ascii.basic.QDPSplitter`.\n505     \"\"\"\n506 \n507     splitter_class = QDPSplitter\n508     comment = \"!\"\n509     write_comment = \"!\"\n510 \n511 \n512 class QDPData(basic.BasicData):\n513     \"\"\"\n514     Data that uses the :class:`astropy.io.ascii.basic.CsvSplitter`.\n515     \"\"\"\n516 \n517     splitter_class = QDPSplitter\n518     fill_values = [(core.masked, \"NO\")]\n519     comment = \"!\"\n520     write_comment = None\n521 \n522 \n523 class QDP(basic.Basic):\n524     \"\"\"Quick and Dandy Plot table.\n525 \n526     Example::\n527 \n528         ! Initial comment line 1\n529         ! Initial comment line 2\n530         READ TERR 1\n531         READ SERR 3\n532         ! Table 0 comment\n533         !a a(pos) a(neg) b be c d\n534         53000.5   0.25  -0.5   1  1.5  3.5 2\n535         54000.5   1.25  -1.5   2  2.5  4.5 3\n536         NO NO NO NO NO\n537         ! Table 1 comment\n538         !a a(pos) a(neg) b be c d\n539         54000.5   2.25  -2.5   NO  3.5  5.5 5\n540         55000.5   3.25  -3.5   4  4.5  6.5 nan\n541 \n542     The input table above contains some initial comments, the error commands,\n543     then two tables.\n544     This file format can contain multiple tables, separated by a line full\n545     of ``NO``s. Comments are exclamation marks, and missing values are single\n546     ``NO`` entries. The delimiter is usually whitespace, more rarely a comma.\n547     The QDP format differentiates between data and error columns. The table\n548     above has commands::\n549 \n550         READ TERR 1\n551         READ SERR 3\n552 \n553     which mean that after data column 1 there will be two error columns\n554     containing its positive and engative error bars, then data column 2 without\n555     error bars, then column 3, then a column with the symmetric error of column\n556     3, then the remaining data columns.\n557 \n558     As explained below, table headers are highly inconsistent. Possible\n559     comments containing column names will be ignored and columns will be called\n560     ``col1``, ``col2``, etc. unless the user specifies their names with the\n561     ``names=`` keyword argument,\n562     When passing column names, pass **only the names of the data columns, not\n563     the error columns.**\n564     Error information will be encoded in the names of the table columns.\n565     (e.g. ``a_perr`` and ``a_nerr`` for the positive and negative error of\n566     column ``a``, ``b_err`` the symmetric error of column ``b``.)\n567 \n568     When writing tables to this format, users can pass an ``err_specs`` keyword\n569     passing a dictionary ``{'serr': [3], 'terr': [1, 2]}``, meaning that data\n570     columns 1 and two will have two additional columns each with their positive\n571     and negative errors, and data column 3 will have an additional column with\n572     a symmetric error (just like the ``READ SERR`` and ``READ TERR`` commands\n573     above)\n574 \n575     Headers are just comments, and tables distributed by various missions\n576     can differ greatly in their use of conventions. For example, light curves\n577     distributed by the Swift-Gehrels mission have an extra space in one header\n578     entry that makes the number of labels inconsistent with the number of cols.\n579     For this reason, we ignore the comments that might encode the column names\n580     and leave the name specification to the user.\n581 \n582     Example::\n583 \n584         >               Extra space\n585         >                   |\n586         >                   v\n587         >!     MJD       Err (pos)       Err(neg)        Rate            Error\n588         >53000.123456   2.378e-05     -2.378472e-05     NO             0.212439\n589 \n590     These readers and writer classes will strive to understand which of the\n591     comments belong to all the tables, and which ones to each single table.\n592     General comments will be stored in the ``initial_comments`` meta of each\n593     table. The comments of each table will be stored in the ``comments`` meta.\n594 \n595     Example::\n596 \n597         t = Table.read(example_qdp, format='ascii.qdp', table_id=1, names=['a', 'b', 'c', 'd'])\n598 \n599     reads the second table (``table_id=1``) in file ``example.qdp`` containing\n600     the table above. There are four column names but seven data columns, why?\n601     Because the ``READ SERR`` and ``READ TERR`` commands say that there are\n602     three error columns.\n603     ``t.meta['initial_comments']`` will contain the initial two comment lines\n604     in the file, while ``t.meta['comments']`` will contain ``Table 1 comment``\n605 \n606     The table can be written to another file, preserving the same information,\n607     as::\n608 \n609         t.write(test_file, err_specs={'terr': [1], 'serr': [3]})\n610 \n611     Note how the ``terr`` and ``serr`` commands are passed to the writer.\n612 \n613     \"\"\"\n614 \n615     _format_name = \"qdp\"\n616     _io_registry_can_write = True\n617     _io_registry_suffix = \".qdp\"\n618     _description = \"Quick and Dandy Plotter\"\n619 \n620     header_class = QDPHeader\n621     data_class = QDPData\n622 \n623     def __init__(self, table_id=None, names=None, err_specs=None, sep=None):\n624         super().__init__()\n625         self.table_id = table_id\n626         self.names = names\n627         self.err_specs = err_specs\n628         self.delimiter = sep\n629 \n630     def read(self, table):\n631         self.lines = self.inputter.get_lines(table, newline=\"\\n\")\n632         return _read_table_qdp(\n633             self.lines,\n634             table_id=self.table_id,\n635             names=self.names,\n636             delimiter=self.delimiter,\n637         )\n638 \n639     def write(self, table):\n640         self._check_multidim_table(table)\n641         lines = _write_table_qdp(table, err_specs=self.err_specs)\n642         return lines\n643 \n[end of astropy/io/ascii/qdp.py]\n</code>\nI need you to solve this issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the following format.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\n"
}